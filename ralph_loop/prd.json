{
  "project": "MedicalImageRegistration.jl",
  "description": "Port torchreg to Julia with GPU-first architecture using AK.jl + Mooncake rrule!!",
  "source": "https://github.com/codingfisch/torchreg",
  "philosophy": {
    "gpu_first": "ALL code runs on GPU via AcceleratedKernels.jl. NO CPU fallbacks. NO nested for loops.",
    "ad_strategy": "Use Mooncake.jl with custom rrule!! for GPU-accelerated backward passes",
    "testing": "Test with Metal.jl MtlArrays locally. All tests must pass on GPU.",
    "no_compromises": "If something doesn't work on GPU with AD, fix it properly. No hacks."
  },
  "loopInstructions": {
    "storyTypes": {
      "NUKE": "Delete old broken code and start fresh",
      "RESEARCH": "Study and document approach before implementing. IMPORTANT: Research stories MUST update/add/modify the implementation stories that follow based on findings. Use the prd.json edit to refine implementation acceptance criteria.",
      "IMPL": "Implement with AK.jl + Mooncake rrule!! from the start",
      "TEST": "Test on Metal GPU with MtlArrays"
    },
    "rules": [
      "EVERY function must work on GPU arrays (MtlArray, CuArray)",
      "EVERY differentiable function needs a Mooncake rrule!!",
      "NO nested for loops - use AK.foreachindex everywhere",
      "NO CPU fallbacks - if it doesn't work on GPU, fix it",
      "Test with MtlArrays locally before marking done",
      "RESEARCH stories MUST edit prd.json to update implementation stories based on findings",
      "If research reveals new requirements, ADD them to blocked IMPL story acceptance criteria",
      "If research reveals the approach is wrong, MODIFY the IMPL story description"
    ]
  },
  "stories": [
    {
      "id": "NUKE-001",
      "type": "NUKE",
      "title": "Delete all existing src/ code and start fresh",
      "status": "done",
      "priority": 1,
      "blockedBy": [],
      "description": "The current implementation is broken - has CPU fallbacks, nested for loops, and AD hacks. Delete ALL files in src/ except MedicalImageRegistration.jl (keep as empty module). We're starting from scratch with GPU-first architecture.",
      "acceptanceCriteria": [
        "All .jl files in src/ deleted except MedicalImageRegistration.jl",
        "MedicalImageRegistration.jl contains only: module declaration, empty exports",
        "No old broken code remains",
        "Git commit with message: [NUKE-001] Clean slate for GPU-first rewrite"
      ],
      "files": ["src/"]
    },
    {
      "id": "RESEARCH-MOONCAKE-001",
      "type": "RESEARCH",
      "title": "Document Mooncake rrule!! pattern for GPU functions",
      "status": "done",
      "priority": 2,
      "blockedBy": ["NUKE-001"],
      "description": "Before implementing, understand exactly how to write Mooncake rrule!! for GPU-accelerated functions. Document the pattern with a simple example. Test that the pattern works with MtlArrays.",
      "acceptanceCriteria": [
        "progress.md documents Mooncake rrule!! signature",
        "progress.md shows CoDual, NoFData, NoRData usage",
        "progress.md has working example with AK.foreachindex in both forward and backward",
        "Example tested with MtlArrays and gradients verified"
      ],
      "files": []
    },
    {
      "id": "IMPL-GRID-001",
      "type": "IMPL",
      "title": "Implement grid_sample with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 3,
      "blockedBy": ["RESEARCH-MOONCAKE-001"],
      "description": "Implement grid_sample from scratch. Forward pass uses AK.foreachindex. Backward pass uses AK.foreachindex. Both registered with Mooncake rrule!!. Must match PyTorch F.grid_sample output.",
      "acceptanceCriteria": [
        "src/grid_sample.jl with grid_sample function using AK.foreachindex",
        "Mooncake rrule!! defined for grid_sample",
        "Backward pass also uses AK.foreachindex",
        "2D (bilinear) and 3D (trilinear) interpolation",
        "padding_mode :zeros and :border",
        "Matches PyTorch F.grid_sample within rtol=1e-5",
        "Works on MtlArrays - test locally",
        "Gradients verified against finite differences on GPU"
      ],
      "files": ["src/grid_sample.jl", "test/test_grid_sample.jl"]
    },
    {
      "id": "IMPL-AFFINE-GRID-001",
      "type": "IMPL",
      "title": "Implement affine_grid with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 4,
      "blockedBy": ["IMPL-GRID-001"],
      "description": "Implement affine_grid that creates sampling grid from affine matrix. Uses AK.foreachindex. Has Mooncake rrule!! for backward pass.",
      "acceptanceCriteria": [
        "src/affine_grid.jl with affine_grid function using AK.foreachindex",
        "Mooncake rrule!! defined",
        "2D and 3D support",
        "Matches PyTorch F.affine_grid within rtol=1e-5",
        "Works on MtlArrays"
      ],
      "files": ["src/affine_grid.jl"]
    },
    {
      "id": "IMPL-COMPOSE-001",
      "type": "IMPL",
      "title": "Implement compose_affine with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 5,
      "blockedBy": ["IMPL-AFFINE-GRID-001"],
      "description": "Implement compose_affine that builds affine matrix from translation, rotation, zoom, shear. GPU-accelerated with Mooncake rrule!!.",
      "acceptanceCriteria": [
        "src/compose_affine.jl using AK.jl operations",
        "Mooncake rrule!! defined",
        "Matches torchreg compose_affine",
        "Works on MtlArrays"
      ],
      "files": ["src/compose_affine.jl"]
    },
    {
      "id": "IMPL-METRICS-001",
      "type": "IMPL",
      "title": "Implement loss functions with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 6,
      "blockedBy": ["IMPL-COMPOSE-001"],
      "description": "Implement MSE, Dice, NCC losses. All GPU-accelerated with AK.jl. All have Mooncake rrule!!.",
      "acceptanceCriteria": [
        "src/metrics.jl with mse_loss, dice_loss, dice_score, NCC",
        "All use AK.jl for GPU acceleration",
        "All have Mooncake rrule!!",
        "Match torchreg metrics",
        "Work on MtlArrays"
      ],
      "files": ["src/metrics.jl"]
    },
    {
      "id": "IMPL-AFFINE-REG-001",
      "type": "IMPL",
      "title": "Implement AffineRegistration with GPU optimization loop",
      "status": "done",
      "priority": 7,
      "blockedBy": ["IMPL-METRICS-001"],
      "description": "Implement full AffineRegistration. Optimization loop runs entirely on GPU. Uses Mooncake for gradients. Uses Optimisers.jl for updates.",
      "acceptanceCriteria": [
        "src/affine.jl with AffineRegistration struct",
        "fit! function runs entirely on GPU",
        "Mooncake computes gradients through entire forward pass",
        "Multi-resolution pyramid support",
        "register() and transform() API",
        "Converges on test cases with MtlArrays"
      ],
      "files": ["src/affine.jl", "src/types.jl"]
    },
    {
      "id": "IMPL-SYN-001",
      "type": "IMPL",
      "title": "Implement SyN diffeomorphic registration on GPU",
      "status": "done",
      "priority": 8,
      "blockedBy": ["IMPL-AFFINE-REG-001"],
      "description": "Implement SyN registration. Scaling-and-squaring, flow composition, all on GPU with Mooncake AD.",
      "acceptanceCriteria": [
        "src/syn.jl with SyNRegistration struct",
        "diffeomorphic_transform using AK.jl",
        "Mooncake rrule!! for all custom ops",
        "Converges on test cases with MtlArrays"
      ],
      "files": ["src/syn.jl"]
    },
    {
      "id": "TEST-PARITY-001",
      "type": "TEST",
      "title": "Full parity tests against torchreg on GPU",
      "status": "done",
      "priority": 9,
      "blockedBy": ["IMPL-SYN-001"],
      "description": "Comprehensive parity tests comparing Julia GPU implementation against torchreg. All tests run on MtlArrays.",
      "acceptanceCriteria": [
        "grid_sample matches PyTorch within rtol=1e-5",
        "affine_grid matches PyTorch within rtol=1e-5",
        "compose_affine matches torchreg",
        "All metrics match torchreg",
        "AffineRegistration converges similarly to torchreg",
        "All tests use MtlArrays"
      ],
      "files": ["test/"]
    },
    {
      "id": "SETUP-CI-001",
      "type": "IMPL",
      "title": "GitHub Actions CI with Metal GPU testing",
      "status": "done",
      "priority": 10,
      "blockedBy": ["TEST-PARITY-001"],
      "description": "Set up CI that tests on macOS with Metal GPU.",
      "acceptanceCriteria": [
        ".github/workflows/ci.yml with macOS runner",
        "Tests run with Metal.jl",
        "CI passes"
      ],
      "files": [".github/workflows/ci.yml"]
    },
    {
      "id": "DEMO-001",
      "type": "IMPL",
      "title": "Demo with TestImages.jl on GPU",
      "status": "done",
      "priority": 11,
      "blockedBy": ["SETUP-CI-001"],
      "description": "Create demo that runs registration on GPU with TestImages.jl.",
      "acceptanceCriteria": [
        "examples/demo.jl runs on GPU",
        "Produces GIF showing registration",
        "README updated"
      ],
      "files": ["examples/demo.jl", "README.md"]
    },
    {
      "id": "DOC-001",
      "type": "IMPL",
      "title": "Document HU conservation and GPU requirements",
      "status": "done",
      "priority": 12,
      "blockedBy": ["DEMO-001"],
      "description": "Document intensity conservation for CT and GPU requirements.",
      "acceptanceCriteria": [
        "README documents HU conservation implications",
        "README documents GPU requirements (Metal/CUDA)",
        "Clear API documentation"
      ],
      "files": ["README.md"]
    },
    {
      "id": "IMPL-NEAREST-001",
      "type": "IMPL",
      "title": "Add nearest-neighbor interpolation to grid_sample",
      "status": "done",
      "priority": 13,
      "blockedBy": ["DOC-001"],
      "description": "Add interpolation_mode kwarg to grid_sample supporting :bilinear/:trilinear (default) and :nearest. Nearest-neighbor preserves original intensity values (critical for HU conservation in CT). Forward pass rounds coordinates to nearest integer instead of bilinear weighting. Backward pass for :nearest returns zero gradients (not differentiable, but that's fine for final output). Must work on GPU with AK.foreachindex.",
      "acceptanceCriteria": [
        "grid_sample accepts interpolation kwarg (:bilinear/:trilinear default, :nearest option)",
        "2D nearest-neighbor: rounds to nearest pixel, returns exact input value",
        "3D nearest-neighbor: rounds to nearest voxel, returns exact input value",
        "Backward pass for :nearest returns zero gradients (non-differentiable)",
        "All padding_mode options work with :nearest",
        "Works on MtlArrays",
        "Matches PyTorch F.grid_sample mode='nearest' within exact equality",
        "Test verifies output values are subset of input values (HU preservation)"
      ],
      "files": ["src/grid_sample.jl", "test/test_grid_sample.jl"]
    },
    {
      "id": "IMPL-HYBRID-001",
      "type": "IMPL",
      "title": "Add hybrid interpolation mode to registration",
      "status": "done",
      "priority": 14,
      "blockedBy": ["IMPL-NEAREST-001"],
      "description": "Add final_interpolation kwarg to register(), transform(), and affine_transform() functions. During optimization, always use bilinear/trilinear for smooth gradients. For final output (and transform() calls), use the specified interpolation mode. Default is :bilinear/:trilinear (unchanged behavior). When final_interpolation=:nearest, the returned image preserves exact input intensity values. Also add to SyN: spatial_transform, apply_flows, etc.",
      "acceptanceCriteria": [
        "register() accepts final_interpolation kwarg (:bilinear default, :nearest option)",
        "transform() accepts interpolation kwarg",
        "affine_transform() accepts interpolation kwarg",
        "AffineRegistration: optimization uses bilinear, final output uses final_interpolation",
        "SyNRegistration: optimization uses trilinear, final output uses final_interpolation",
        "spatial_transform() accepts interpolation kwarg",
        "Default behavior unchanged (bilinear/trilinear throughout)",
        "Works on MtlArrays for both modes",
        "Documentation updated with HU preservation workflow"
      ],
      "files": ["src/affine.jl", "src/syn.jl", "src/types.jl"]
    },
    {
      "id": "TEST-HU-001",
      "type": "TEST",
      "title": "Test HU preservation with hybrid interpolation",
      "status": "done",
      "priority": 15,
      "blockedBy": ["IMPL-HYBRID-001"],
      "description": "Comprehensive tests verifying that final_interpolation=:nearest preserves exact intensity values. Test with synthetic CT-like data with known HU values. Verify that output image values are always a subset of input image values. Test both AffineRegistration and SyNRegistration.",
      "acceptanceCriteria": [
        "Test: grid_sample :nearest output values ⊆ input values",
        "Test: AffineRegistration with final_interpolation=:nearest preserves HU",
        "Test: SyNRegistration with final_interpolation=:nearest preserves HU",
        "Test: transform() with interpolation=:nearest preserves HU",
        "Test: synthetic CT with HU=-1000 (air), 0 (water), 1000 (bone) - values unchanged",
        "Test: registration still converges with hybrid mode (bilinear optimize, nearest output)",
        "All tests on MtlArrays",
        "Document example workflow in test comments"
      ],
      "files": ["test/test_hu_preservation.jl"]
    },
    {
      "id": "DEMO-HU-001",
      "type": "IMPL",
      "title": "Shepp-Logan phantom demo comparing standard vs HU-preserving registration",
      "status": "done",
      "priority": 16,
      "blockedBy": ["TEST-HU-001"],
      "description": "Create a comprehensive demo using the Shepp-Logan phantom (3D via TestImages.shepp_logan(128) if available, otherwise 2D with TestImages.shepp_logan(256)) that visually demonstrates the difference between standard bilinear interpolation and HU-preserving nearest-neighbor hybrid mode. Generate side-by-side GIFs and quantitative analysis showing intensity value preservation.",
      "acceptanceCriteria": [
        "examples/demo_hu_preservation.jl created",
        "Uses TestImages.shepp_logan() - prefer 3D shepp_logan(128) if available, fallback to 2D shepp_logan(256)",
        "Creates synthetic misalignment (rotation + translation)",
        "Runs registration with BOTH modes: standard (bilinear) and hybrid (final_interpolation=:nearest)",
        "Generates GIF: registration_standard.gif showing bilinear interpolation result",
        "Generates GIF: registration_hu_preserving.gif showing nearest-neighbor result",
        "Generates comparison image showing intensity histogram before/after for both modes",
        "Prints quantitative analysis: unique values before vs after, min/max values, value drift statistics",
        "Demo shows that hybrid mode output values are EXACT subset of input values",
        "Demo shows standard mode creates NEW interpolated values not in original",
        "README.md updated with Shepp-Logan demo section and output images",
        "README shows side-by-side comparison of the two approaches",
        "Clear explanation of when to use each mode (visual alignment vs quantitative analysis)",
        "Works on GPU (MtlArray) with CPU fallback"
      ],
      "files": ["examples/demo_hu_preservation.jl", "README.md", "examples/output/"]
    },
    {
      "id": "RESEARCH-CLINICAL-001",
      "type": "RESEARCH",
      "title": "Research clinical CT registration challenges and solutions",
      "status": "done",
      "priority": 17,
      "blockedBy": ["DEMO-HU-001"],
      "description": "Research the challenges of registering real clinical CT scans with mismatched parameters. USE THIS CONCRETE SCENARIO THROUGHOUT: Scan 1 (static): 3mm slice thickness, large FOV (more lung visible), NON-CONTRAST cardiac CT. Scan 2 (moving): 0.5mm slice thickness, tight FOV (less lung), WITH CONTRAST cardiac CT. GOAL: Register these for QUANTITATIVE ANALYSIS where HU accuracy matters (e.g., calcium scoring, tissue density measurement, dose calculation). Document gaps and propose solutions. RESEARCH ONLY - no implementation.",
      "acceptanceCriteria": [
        "Document the CONCRETE USE CASE at the top: cardiac CT, 3mm non-contrast vs 0.5mm contrast, quantitative HU accuracy required",
        "Document in progress.md: DICOM coordinate system (ImagePositionPatient, PixelSpacing, SliceThickness, ImageOrientationPatient)",
        "Document: How to convert between voxel coordinates and physical (mm) coordinates",
        "Document: The problem with contrast vs non-contrast registration - WHY does blood go from 40 HU to 300+ HU?",
        "Document: Specific cardiac structures affected by contrast (chambers, coronary arteries, aorta)",
        "Document: Mutual Information loss - what it is, why it handles multi-modal registration",
        "Document: Anisotropic voxel handling (3mm z vs 0.5mm z) - 6x resolution difference!",
        "Document: The inverse-resampling workflow for true HU preservation",
        "Document: Mask-weighted registration for handling FOV mismatch (tight FOV misses lung)",
        "Document: Quantitative accuracy requirements - what tolerance is acceptable for calcium scoring?",
        "Create a gap analysis table: what current library has vs what's needed FOR THIS USE CASE",
        "Propose implementation order for new features",
        "Research existing Julia packages: DICOM.jl, NIfTI.jl for coordinate handling",
        "NO CODE IMPLEMENTATION - research and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "RESEARCH-MI-001",
      "type": "RESEARCH",
      "title": "Research Mutual Information loss for multi-modal registration",
      "status": "done",
      "priority": 18,
      "blockedBy": ["RESEARCH-CLINICAL-001"],
      "description": "Deep dive into Mutual Information (MI) as a registration loss function. CONTEXT: For our cardiac CT use case (3mm non-contrast vs 0.5mm contrast), MSE/NCC fail because contrast agent changes intensities dramatically. MI measures statistical dependence - if heart blood is always 40 HU in non-contrast and 300 HU in contrast, MI learns this mapping. Research math, GPU challenges, and Mooncake integration.",
      "acceptanceCriteria": [
        "Reference the cardiac CT use case: why MSE fails when blood is 40 HU vs 300 HU",
        "Document MI formula: MI(X,Y) = H(X) + H(Y) - H(X,Y) where H is entropy",
        "Document: Why MI works for contrast/non-contrast (joint histogram learns intensity mapping)",
        "Document: Example joint histogram for cardiac CT - what would it look like?",
        "Document: Parzen window / kernel density estimation for differentiable MI",
        "Document: GPU implementation challenges (histogram binning on GPU with AK.jl)",
        "Document: How torchreg or other libraries implement MI (check ANTs, SimpleITK, etc.)",
        "Document: Normalized Mutual Information (NMI) variant - why it might be better",
        "Document: How to make MI differentiable for gradient-based optimization",
        "Document: Mooncake rrule!! considerations for MI loss - can we autodiff through histograms?",
        "Document: Expected computational cost vs MSE/NCC",
        "Propose implementation approach with AK.jl",
        "NO CODE IMPLEMENTATION - research and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "RESEARCH-PHYSICAL-001",
      "type": "RESEARCH",
      "title": "Research physical coordinate system and anisotropic voxels",
      "status": "done",
      "priority": 19,
      "blockedBy": ["RESEARCH-MI-001"],
      "description": "Research how to properly handle physical coordinates and anisotropic voxels. CONTEXT: Our cardiac CT case has 3mm z-spacing (static) vs 0.5mm z-spacing (moving) - that's 6x difference! Current library uses normalized [-1,1] and treats all voxels as isotropic. A 10-voxel displacement means very different things in physical space. Need to understand coordinate handling for accurate registration.",
      "acceptanceCriteria": [
        "Reference cardiac CT case: 3mm vs 0.5mm z-spacing, what happens if we ignore this?",
        "Document: DICOM coordinate system in detail (LPS vs RAS)",
        "Document: Key DICOM tags for our use case (SliceThickness vs SpacingBetweenSlices)",
        "Document: NIfTI affine matrix and sform/qform",
        "Document: How to compute physical position (mm) of any voxel",
        "Document: The problem - current affine_grid assumes isotropic voxels",
        "Document: Anisotropic grid generation (spacing-aware affine_grid)",
        "Document: How PyTorch/torchreg handles this (or doesn't)",
        "Document: Resampling strategies - should we resample 3mm to 0.5mm or vice versa?",
        "Document: The 'register at low res, apply at high res' workflow in detail",
        "Document: Transform interpolation - upsampling displacement field from 2mm to 0.5mm",
        "Document: What resolution to register at? Trade-offs of 1mm vs 2mm vs 3mm",
        "Propose API changes to support physical coordinates (PhysicalImage type?)",
        "Example: Our two cardiac CTs - step by step what should happen?",
        "NO CODE IMPLEMENTATION - research and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "RESEARCH-WORKFLOW-001",
      "type": "RESEARCH",
      "title": "Design end-to-end clinical CT registration workflow",
      "status": "done",
      "priority": 20,
      "blockedBy": ["RESEARCH-PHYSICAL-001"],
      "description": "Based on previous research, design the COMPLETE workflow for our specific use case: Patient has cardiac CT #1 (3mm, large FOV, non-contrast) and cardiac CT #2 (0.5mm, tight FOV, contrast). Goal: Register them so we can do quantitative analysis (calcium scoring, tissue density) on the registered result with EXACT HU preservation. Design concrete API and implementation plan.",
      "acceptanceCriteria": [
        "Write out the EXACT clinical scenario at the top with specific numbers",
        "Document: Why this matters - calcium scoring requires accurate HU (130 HU threshold)",
        "Document: Complete workflow from two DICOM folders to quantitatively accurate registered output",
        "Document: Step 1 - Load both DICOM series, extract metadata",
        "Document: Step 2 - Compute initial alignment from DICOM headers (are they already in same physical space?)",
        "Document: Step 3 - Determine overlapping FOV (tight FOV is subset of large FOV)",
        "Document: Step 4 - Create common reference grid at registration resolution (e.g., 2mm isotropic)",
        "Document: Step 5 - Downsample BOTH to registration grid (bilinear ok, just for optimization)",
        "Document: Step 6 - Register with MI loss + SyN diffeomorphic (handles local deformation)",
        "Document: Step 7 - Upsample displacement field to 0.5mm resolution",
        "Document: Step 8 - Apply transform to ORIGINAL 0.5mm image with nearest-neighbor",
        "Document: Step 9 - Validation - check that output HU values are exact subset of input",
        "Document: What if user wants to go the other direction (register static to moving)?",
        "Propose: New structs/types (PhysicalImage, DICOMSeries, RegistrationWorkspace)",
        "Propose: New functions (load_dicom_series, compute_overlap_region, resample_transform)",
        "Propose: Changes to existing register() - add physical_coords=true option?",
        "Propose: High-level API - register_clinical(dicom_folder1, dicom_folder2; preserve_hu=true)",
        "Create implementation roadmap with story IDs and dependencies",
        "Estimate complexity (S/M/L) and priority for each new feature",
        "Identify which features are MUST-HAVE vs NICE-TO-HAVE for the cardiac CT use case",
        "NO CODE IMPLEMENTATION - design and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "IMPL-MI-001",
      "type": "IMPL",
      "title": "Implement Mutual Information loss with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 21,
      "blockedBy": ["RESEARCH-WORKFLOW-001"],
      "description": "Implement Mutual Information (MI) loss for multi-modal registration. CONTEXT: For cardiac CT registration (3mm non-contrast vs 0.5mm contrast), MSE fails because contrast changes blood from 40 HU to 300+ HU. MI measures statistical dependence - learns that 40 HU non-contrast = 300 HU contrast. Use differentiable Parzen window estimation. Must work on GPU with AK.jl and have Mooncake rrule!! for backward pass.",
      "acceptanceCriteria": [
        "src/mi_loss.jl with mi_loss function",
        "Differentiable via Parzen window / kernel density estimation",
        "Forward pass: compute joint histogram with AK.foreachindex, then entropy",
        "Backward pass: Mooncake rrule!! using AK.foreachindex",
        "Configurable: number of bins (default 64), kernel sigma",
        "Also implement nmi_loss (Normalized MI) - more robust",
        "Works on MtlArrays - GPU accelerated",
        "Test: mi_loss handles contrast/non-contrast correctly (should decrease as alignment improves)",
        "Test: Gradients verified against finite differences",
        "Test: Matches reference implementation (compare to SimpleITK or ANTs MI if possible)",
        "Document in code: why MI for multi-modal, when to use vs MSE/NCC"
      ],
      "files": ["src/mi_loss.jl", "test/test_mi_loss.jl"]
    },
    {
      "id": "IMPL-PHYSICAL-001",
      "type": "IMPL",
      "title": "Implement physical coordinate handling and spacing-aware grids",
      "status": "done",
      "priority": 22,
      "blockedBy": ["IMPL-MI-001"],
      "description": "Add physical coordinate support for anisotropic voxels. CONTEXT: Cardiac CT case has 3mm z-spacing (static) vs 0.5mm z-spacing (moving) - 6x difference! Current library assumes isotropic normalized [-1,1]. Need spacing-aware grid generation. Add PhysicalImage type that wraps array + spacing + origin. Modify affine_grid and grid_sample to handle physical coordinates.",
      "acceptanceCriteria": [
        "src/physical.jl with PhysicalImage{T,N} struct wrapping (data, spacing, origin)",
        "PhysicalImage stores: data array (X,Y,Z,C,N), spacing tuple (mm), origin tuple (mm)",
        "Constructor: PhysicalImage(data; spacing=(1,1,1), origin=(0,0,0))",
        "affine_grid_physical(theta, image::PhysicalImage) - generates grid in physical coordinates",
        "Grid accounts for anisotropic spacing (a 1mm translation in z = 2 voxels at 0.5mm spacing)",
        "grid_sample works with PhysicalImage, respecting spacing",
        "resample(image::PhysicalImage, target_spacing) - resample to new spacing",
        "resample uses spacing-aware grid internally",
        "Mooncake rrule!! for all new differentiable operations",
        "Works on MtlArrays with AK.foreachindex",
        "Test: Create PhysicalImage with anisotropic spacing, verify grid is correct",
        "Test: Affine transform accounts for spacing difference",
        "Test: Round-trip resample(img, new_spacing) then resample back preserves shape/values"
      ],
      "files": ["src/physical.jl", "test/test_physical.jl"]
    },
    {
      "id": "IMPL-RESAMPLE-001",
      "type": "IMPL",
      "title": "Implement displacement field resampling for multi-resolution workflow",
      "status": "done",
      "priority": 23,
      "blockedBy": ["IMPL-PHYSICAL-001"],
      "description": "Implement functions to upsample/downsample displacement fields. CONTEXT: For cardiac CT workflow, we register at low resolution (2mm isotropic for speed) but need to apply the transform to the high-resolution (0.5mm) original image. Need to upsample the displacement field while maintaining diffeomorphic properties. Also need inverse transform computation for bidirectional registration.",
      "acceptanceCriteria": [
        "src/resample_transform.jl with core functions",
        "resample_displacement(disp_field, target_size) - bilinear/trilinear upsample of displacement field",
        "Displacement values scaled by resolution ratio (2mm->0.5mm means 4x the voxel displacement)",
        "resample_velocity(velocity_field, target_size) - for SyN velocity fields",
        "upsample_affine_transform(theta, old_size, new_size) - adjust affine for resolution change",
        "invert_displacement(disp_field; iterations=10) - iterative inverse (for bidirectional)",
        "All use AK.foreachindex for GPU",
        "All have Mooncake rrule!! (even if gradient is rarely needed)",
        "Works on MtlArrays",
        "Test: Upsample 2x then downsample 2x ≈ identity",
        "Test: Displacement scaling is correct (value * resolution_ratio)",
        "Test: Inverse displacement field inverts original transform (within tolerance)"
      ],
      "files": ["src/resample_transform.jl", "test/test_resample_transform.jl"]
    },
    {
      "id": "IMPL-CLINICAL-001",
      "type": "IMPL",
      "title": "Implement high-level clinical registration API",
      "status": "done",
      "priority": 24,
      "blockedBy": ["IMPL-RESAMPLE-001"],
      "description": "Implement high-level API for clinical CT registration workflow. Combines all previous features into a simple interface. Takes two PhysicalImage arrays, handles resolution mismatch, uses MI loss, applies transform with HU preservation. Should be usable directly from the cardiac_ct.jl notebook.",
      "acceptanceCriteria": [
        "src/clinical.jl with high-level functions",
        "register_clinical(moving::PhysicalImage, static::PhysicalImage; kwargs) - main entry point",
        "Parameters: registration_resolution (default 2mm), loss_fn (default mi_loss), preserve_hu (default true)",
        "Workflow: 1) resample both to registration_resolution, 2) run registration with MI, 3) upsample transform, 4) apply to original with nearest-neighbor",
        "ClinicalRegistrationResult struct with: moved_image, transform, metrics, metadata",
        "transform_clinical(result, image::PhysicalImage) - apply learned transform to another image",
        "Support both AffineRegistration and SyNRegistration via registration_type kwarg",
        "Works entirely on GPU (MtlArrays)",
        "Verbose mode prints: resolution info, registration progress, final metrics",
        "Test: Full workflow with synthetic anisotropic images",
        "Test: Output HU values ⊆ input HU values when preserve_hu=true",
        "Document: Complete example in docstring"
      ],
      "files": ["src/clinical.jl", "test/test_clinical.jl"]
    },
    {
      "id": "TEST-CARDIAC-001",
      "type": "TEST",
      "title": "Test clinical registration on cardiac CT notebook",
      "status": "done",
      "priority": 25,
      "blockedBy": ["IMPL-CLINICAL-001"],
      "description": "Update cardiac_ct.jl notebook to use the new clinical registration API. Test the full pipeline: load DICOMs -> create PhysicalImage -> register with MI loss -> apply transform with HU preservation -> visualize and validate results. This is the ultimate integration test for the cardiac CT use case.",
      "acceptanceCriteria": [
        "examples/cardiac_ct.jl updated with registration cells",
        "Uses load_dicom_volume function already in notebook to get PhysicalImage",
        "Creates PhysicalImage from volume + spacing from DICOM metadata",
        "Calls register_clinical(ccta, non_contrast; preserve_hu=true)",
        "Visualizes: before/after alignment with checkerboard overlay",
        "Visualizes: difference image before/after registration",
        "Validates: Output HU values are exact subset of input (nearest-neighbor working)",
        "Validates: MI loss decreased (alignment improved)",
        "Reports: Registration metrics (MI before/after, NCC before/after)",
        "Reports: Physical metadata (spacing, size, FOV)",
        "Handles the 3mm vs 0.5mm resolution difference correctly",
        "Works on Metal GPU",
        "Add markdown cells explaining each step of the workflow",
        "Notebook can be run end-to-end without errors"
      ],
      "files": ["examples/cardiac_ct.jl"]
    },
    {
      "id": "DOC-CLINICAL-001",
      "type": "IMPL",
      "title": "Document clinical registration workflow in README",
      "status": "done",
      "priority": 26,
      "blockedBy": ["TEST-CARDIAC-001"],
      "description": "Update README with clinical registration documentation. Add new section explaining the multi-modal registration workflow with concrete cardiac CT example. Document when to use MI vs MSE/NCC. Document physical coordinate handling and HU preservation.",
      "acceptanceCriteria": [
        "README.md has new 'Clinical CT Registration' section",
        "Documents the cardiac CT scenario: non-contrast 3mm vs contrast 0.5mm",
        "Shows complete code example using register_clinical()",
        "Explains MI loss and when to use it (contrast mismatch)",
        "Explains physical coordinates and why they matter (anisotropic voxels)",
        "Explains HU preservation workflow (preserve_hu=true)",
        "Documents PhysicalImage type and how to create one",
        "Documents ClinicalRegistrationResult and what it contains",
        "Table: Which loss to use (MSE for same-modality, MI for different-modality)",
        "Table: Interpolation mode selection (bilinear for visual, nearest for quantitative)",
        "Link to cardiac_ct.jl notebook as example",
        "Clear API reference for new functions"
      ],
      "files": ["README.md"]
    },
    {
      "id": "RESEARCH-ANTS-PREPROCESS-001",
      "type": "RESEARCH",
      "title": "Research ANTs preprocessing pipeline for CT registration",
      "status": "done",
      "priority": 27,
      "blockedBy": ["DOC-CLINICAL-001"],
      "description": "The current cardiac_ct.jl registration FAILS - before/after images are nearly identical (see screenshot). ANTs does extensive preprocessing BEFORE optimization that we're missing. Research exactly what ANTs does: initial alignment, resampling, center-of-mass alignment, histogram matching, etc. Document step-by-step what preprocessing makes registration actually work.",
      "acceptanceCriteria": [
        "Document: WHY current registration fails (no initial alignment, FOV mismatch, resolution mismatch)",
        "Research ANTs antsRegistration preprocessing steps in order",
        "Document: Center-of-mass (COM) alignment - what it does, why critical for FOV mismatch",
        "Document: antsApplyTransforms initial alignment using DICOM headers",
        "Document: How ANTs handles different FOVs (tight CCTA vs wide non-contrast)",
        "Document: ANTs resampling strategy - what resolution, what interpolation",
        "Document: ANTs histogram matching / intensity normalization for MI",
        "Document: ANTs multi-resolution pyramid strategy (shrink factors, smoothing sigmas)",
        "Document: ANTs initialization options (geometric center, center of mass, image origins)",
        "Research: What makes ANTs registration robust that we're missing?",
        "Create concrete checklist: preprocessing steps needed before calling register()",
        "Identify: Which preprocessing can be done on GPU vs must be CPU",
        "**UPDATE prd.json**: Modify IMPL-PREPROCESS-001 acceptance criteria based on findings",
        "**UPDATE prd.json**: Add any new functions discovered to IMPL-PREPROCESS-001",
        "**UPDATE prd.json**: If ANTs does something unexpected, add it to implementation stories",
        "NO CODE - research and documentation only, but MUST update implementation stories"
      ],
      "files": ["ralph_loop/progress.md", "ralph_loop/prd.json"]
    },
    {
      "id": "RESEARCH-INITIAL-ALIGNMENT-001",
      "type": "RESEARCH",
      "title": "Research initial alignment strategies for mismatched FOV",
      "status": "done",
      "priority": 28,
      "blockedBy": ["RESEARCH-ANTS-PREPROCESS-001"],
      "description": "Deep dive into initial alignment for our specific case: CCTA (tight FOV, 0.5mm, contrast) vs Non-contrast (wide FOV, 3mm, no contrast). The images are in different physical spaces. Without initial alignment, optimization can't even start properly. Research how to use DICOM headers, center-of-mass, and overlap regions. IMPORTANT: Update the implementation stories based on findings.",
      "acceptanceCriteria": [
        "Document: The EXACT problem - CCTA FOV is SUBSET of non-contrast FOV",
        "Document: DICOM ImagePositionPatient - are images already in same physical space?",
        "Document: If DICOM says same space, why might they still be misaligned? (table position, breath hold)",
        "Document: Center-of-mass alignment algorithm step-by-step",
        "Document: How to compute COM for CT images (threshold air at -500 HU first?)",
        "Document: Overlap region detection - find where tight FOV fits in wide FOV",
        "Document: Crop vs pad strategies for FOV mismatch",
        "Document: Initial transform estimation from DICOM headers",
        "Research: SimpleITK CenteredTransformInitializer - what does it do?",
        "Research: ANTs antsAI (ANTs AI) for automatic initialization",
        "Propose: Initial alignment function API for MedicalImageRegistration.jl",
        "**UPDATE prd.json**: Refine IMPL-PREPROCESS-001 with specific algorithm details",
        "**UPDATE prd.json**: Add exact function signatures based on research",
        "**UPDATE prd.json**: If crop vs pad decision made, update acceptance criteria",
        "NO CODE - research and documentation only, but MUST update implementation stories"
      ],
      "files": ["ralph_loop/progress.md", "ralph_loop/prd.json"]
    },
    {
      "id": "IMPL-PREPROCESS-001",
      "type": "IMPL",
      "title": "Implement preprocessing pipeline for clinical CT registration",
      "status": "done",
      "priority": 29,
      "blockedBy": ["RESEARCH-INITIAL-ALIGNMENT-001"],
      "description": "Implement the preprocessing steps identified in ANTs research. This is CRITICAL - without proper preprocessing, registration fails because gradient descent cannot escape local minimum when starting from grossly misaligned images. The preprocessing pipeline must: 1) Compute center of mass for intensity-weighted alignment, 2) Detect FOV overlap since CCTA is a subset of non-contrast FOV, 3) Align image centers before optimization, 4) Resample to common space. All operations must work on GPU with MtlArrays.",
      "acceptanceCriteria": [
        "src/preprocess.jl with preprocessing functions",
        "**center_of_mass(image::PhysicalImage; threshold=-200f0)** - compute intensity-weighted COM in physical coordinates (mm)",
        "  - Threshold excludes air (HU < threshold) from computation",
        "  - Returns (x_mm, y_mm, z_mm) tuple in physical space",
        "  - Uses AK.foreachindex for GPU acceleration",
        "  - Works with anisotropic voxels (different x,y,z spacing)",
        "**align_centers(moving::PhysicalImage, static::PhysicalImage; threshold=-200f0)** - returns translated moving image",
        "  - Computes COM for both images",
        "  - Applies translation: translation = COM_static - COM_moving",
        "  - Returns new PhysicalImage with adjusted origin (NOT resampled data)",
        "  - Also returns the translation vector for composing with registration transform",
        "**compute_overlap_region(img1::PhysicalImage, img2::PhysicalImage)** - returns overlapping bounding box",
        "  - Returns (min_corner, max_corner) in physical coordinates (mm)",
        "  - Handles images with different FOVs",
        "  - Returns nothing if images don't overlap at all",
        "**crop_to_overlap(image::PhysicalImage, region)** - crops to specified physical region",
        "  - Takes region from compute_overlap_region()",
        "  - Returns new PhysicalImage with cropped data and updated origin",
        "  - Uses nearest-voxel boundaries (no interpolation for crop)",
        "**window_intensity(image; min_hu=-200f0, max_hu=1000f0)** - clips intensity values",
        "  - Clamps values to [min_hu, max_hu] range",
        "  - Uses AK.foreachindex for GPU",
        "  - Returns new array with windowed values",
        "**preprocess_for_registration(moving::PhysicalImage, static::PhysicalImage; kwargs...)** - MAIN PIPELINE",
        "  - Parameters: registration_resolution=2.0f0, align_com=true, crop_to_overlap=true, window_hu=true",
        "  - Step 1: Compute and align centers of mass (if align_com=true)",
        "  - Step 2: Detect overlapping FOV region",
        "  - Step 3: Crop both images to overlap (if crop_to_overlap=true)",
        "  - Step 4: Resample both to registration_resolution (uses existing resample())",
        "  - Step 5: Apply intensity windowing (if window_hu=true)",
        "  - Returns: (preprocessed_moving, preprocessed_static, preprocess_transform)",
        "  - preprocess_transform is the translation that was applied (for later composition)",
        "All functions work on GPU (AK.foreachindex where needed)",
        "Mooncake rrule!! for differentiable operations (NOT needed - preprocessing is not optimized through)",
        "Test: center_of_mass returns correct physical coordinates for known image",
        "Test: align_centers makes COMs match within tolerance",
        "Test: compute_overlap_region handles images with partial overlap",
        "Test: compute_overlap_region returns nothing for non-overlapping images",
        "Test: crop_to_overlap produces image with correct physical extent",
        "Test: Full pipeline makes images visually overlap (checkerboard should show alignment)",
        "Test: All operations preserve MtlArray type (stay on GPU)",
        "Test: center_of_mass handles anisotropic spacing (e.g., 0.5mm x 0.5mm x 3mm)",
        "Test: align_centers tolerance within 0.1mm after alignment",
        "Test: Synthetic cardiac CT scenario - tight FOV (180mm) inside wide FOV (350mm) works correctly"
      ],
      "files": ["src/preprocess.jl", "test/test_preprocess.jl"]
    },
    {
      "id": "IMPL-REGISTER-PIPELINE-001",
      "type": "IMPL",
      "title": "Implement complete registration pipeline with preprocessing",
      "status": "done",
      "priority": 30,
      "blockedBy": ["IMPL-PREPROCESS-001"],
      "description": "Update register_clinical() to include preprocessing pipeline. The current version throws raw images at registration. New version: 1) preprocess (align centers, resample), 2) register at low res, 3) refine at higher res, 4) apply to original with HU preservation.",
      "acceptanceCriteria": [
        "register_clinical() now calls preprocess_for_registration() first",
        "Add preprocess=true kwarg (default true) to skip if user pre-aligned",
        "Add center_of_mass_init=true kwarg for COM alignment",
        "Pipeline: preprocess → coarse registration → fine registration → apply transform",
        "Multi-resolution handled INTERNALLY (user doesn't need to specify shrink factors)",
        "Verbose mode shows preprocessing steps and intermediate alignment quality",
        "Returns: original moving image transformed, NOT the preprocessed version",
        "Transform is composed: preprocessing_transform ∘ registration_transform",
        "Test: Run on cardiac_ct.jl data - should now show visible improvement",
        "Test: Checkerboard overlay should show better alignment than before"
      ],
      "files": ["src/clinical.jl", "test/test_clinical.jl"]
    },
    {
      "id": "FIX-NOTEBOOK-001",
      "type": "IMPL",
      "title": "Fix cardiac_ct.jl notebook with working registration",
      "status": "done",
      "priority": 31,
      "blockedBy": ["IMPL-REGISTER-PIPELINE-001"],
      "description": "Update the cardiac_ct.jl notebook to use the fixed registration pipeline. The current notebook shows registration FAILING (before/after nearly identical). After this fix, the notebook should show clear improvement in alignment. Add diagnostic cells to show what preprocessing is doing.",
      "acceptanceCriteria": [
        "Update register_clinical() call to use new preprocessing",
        "Add cell showing center-of-mass values for both images",
        "Add cell showing overlap region detection result",
        "Add cell showing images AFTER preprocessing but BEFORE registration",
        "Add cell comparing: original → preprocessed → registered",
        "Checkerboard overlay should show CLEAR improvement (smooth edges)",
        "Difference image should show REDUCED error after registration",
        "Add quantitative metrics: NCC before/after, MI before/after",
        "Notebook runs end-to-end without errors",
        "Visual inspection confirms registration is actually working"
      ],
      "files": ["examples/cardiac_ct.jl"]
    },
    {
      "id": "RESEARCH-HYBRID-ANTS-001",
      "type": "RESEARCH",
      "title": "Research hybrid approach: ANTs preprocessing + our GPU registration",
      "status": "done",
      "priority": 32,
      "blockedBy": ["FIX-NOTEBOOK-001"],
      "description": "After fixing basic preprocessing, research if we should use ANTs (via ANTsPy or shell) for preprocessing and our library for GPU-accelerated registration. ANTs has 20+ years of robust preprocessing. We have fast GPU registration. Could be best of both worlds. Research the interface.",
      "acceptanceCriteria": [
        "Document: What ANTs preprocessing is hard to replicate (N4 bias correction?)",
        "Document: What ANTs preprocessing we CAN replicate easily",
        "Research: ANTsPy Python package - can we call from Julia via PythonCall?",
        "Research: ANTs command line - can we shell out for preprocessing?",
        "Document: Workflow - ANTs preprocess → save NIfTI → load in Julia → GPU register",
        "Document: Performance comparison - is ANTs preprocessing fast enough?",
        "Evaluate: Is hybrid approach worth the complexity?",
        "Propose: If hybrid, what's the cleanest API?",
        "Consider: Pure Julia fallback for users without ANTs installed",
        "**IF hybrid recommended**: ADD new IMPL story for ANTs integration to prd.json",
        "**IF hybrid recommended**: ADD new story for ANTsPy wrapper functions",
        "**IF NOT recommended**: Document why pure Julia is sufficient",
        "**UPDATE prd.json**: Add or modify stories based on decision",
        "NO CODE - research and decision document only, but MUST update prd.json with next steps"
      ],
      "decision": "DO NOT integrate ANTs for CT preprocessing. N4 bias correction is for MRI, not CT. Our pure Julia preprocessing (COM alignment, FOV overlap, HU windowing) is sufficient for CT registration. For future MRI support, consider optional ANTsPy extension package.",
      "files": ["ralph_loop/progress.md", "ralph_loop/prd.json"]
    }
  ]
}

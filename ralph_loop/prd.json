{
  "project": "MedicalImageRegistration.jl",
  "description": "Port torchreg (PyTorch image registration) to idiomatic Julia with full parity testing",
  "source": "https://github.com/codingfisch/torchreg",
  "loopInstructions": {
    "storyTypes": {
      "RESEARCH": "Deep-dive study with documentation. Read source files, understand algorithms, document findings in progress.md",
      "SETUP": "Create infrastructure (files, configs, test harnesses). Verify with basic smoke tests",
      "IMPL": "Implement feature following Julia idioms. Must pass type checks and basic tests",
      "TEST": "Write parity tests comparing Julia vs torchreg via PythonCall. All tests must pass",
      "FIX": "Fix issues discovered during implementation or testing"
    },
    "workflowRules": [
      "Pick lowest-priority OPEN story where all blockedBy are DONE",
      "Read the story description and acceptance criteria carefully",
      "For IMPL stories: implement in idiomatic Julia, NOT line-by-line translation",
      "For TEST stories: use PythonCall to compare with torchreg on identical inputs",
      "Mark story DONE only when ALL acceptance criteria are met",
      "Commit after each completed story with message: [STORY-ID] description",
      "If blocked, document in progress.md and output RALPH_BLOCKED"
    ],
    "juliaConventions": {
      "arrayAxes": {
        "2D": "(X, Y, C, N) where X=width, Y=height, C=channels, N=batch",
        "3D": "(X, Y, Z, C, N) where X=width, Y=height, Z=depth",
        "note": "Julia is column-major. PyTorch is (N, C, ..spatial..). Permute axes in tests."
      },
      "naming": {
        "functions": "snake_case (register, get_affine, affine_transform)",
        "types": "PascalCase (AffineRegistration, SyNRegistration)",
        "constants": "SCREAMING_SNAKE_CASE"
      },
      "style": "Use multiple dispatch, keyword arguments, type annotations where helpful"
    },
    "adLibrary": {
      "options": ["Enzyme.jl", "Mooncake.jl"],
      "prohibited": "Zygote.jl",
      "note": "RESEARCH-AD-001 evaluates both. Choice must be BAKED IN - users should never think about AD library. DO NOT use Zygote.jl."
    },
    "gpuStrategy": {
      "library": "AcceleratedKernels.jl",
      "platforms": ["CPU", "Metal (Apple Silicon)", "CUDA"],
      "testing": {
        "local": "Mac with Metal GPU for development",
        "ci": "GitHub Actions with macos runner for Metal, ubuntu for CPU",
        "note": "Tests must verify GPU acceleration actually works, not just that code runs"
      }
    }
  },
  "stories": [
    {
      "id": "RESEARCH-001",
      "type": "RESEARCH",
      "title": "Deep dive into torchreg architecture and algorithms",
      "status": "done",
      "priority": 1,
      "blockedBy": [],
      "description": "Study the torchreg source code in /Users/daleblack/Documents/dev/torchreg_temp/torchreg/. Document: (1) How affine_transform works with F.affine_grid + F.grid_sample, (2) How compose_affine builds the affine matrix from translation/rotation/zoom/shear, (3) How SyN diffeomorphic transform uses scaling-and-squaring, (4) All loss functions and their formulas.",
      "acceptanceCriteria": [
        "progress.md contains detailed notes on affine_transform implementation",
        "progress.md contains compose_affine matrix construction formula",
        "progress.md contains SyN diffeomorphic algorithm explanation",
        "progress.md contains all metric formulas (MSE, Dice, NCC, LinearElasticity)"
      ],
      "files": [
        "/Users/daleblack/Documents/dev/torchreg_temp/torchreg/affine.py",
        "/Users/daleblack/Documents/dev/torchreg_temp/torchreg/syn.py",
        "/Users/daleblack/Documents/dev/torchreg_temp/torchreg/metrics.py",
        "/Users/daleblack/Documents/dev/torchreg_temp/torchreg/utils.py"
      ]
    },
    {
      "id": "RESEARCH-002",
      "type": "RESEARCH",
      "title": "Research Julia equivalents for PyTorch operations",
      "status": "done",
      "priority": 1,
      "blockedBy": ["RESEARCH-001"],
      "description": "Document how to implement torchreg operations in Julia: (1) NNlib.grid_sample vs F.grid_sample API differences, (2) How to create affine_grid in Julia (meshgrid + matmul), (3) Enzyme.jl gradient API for custom operations, (4) Optimisers.jl API vs torch.optim.",
      "acceptanceCriteria": [
        "progress.md documents NNlib.grid_sample signature and padding modes",
        "progress.md shows affine_grid implementation approach",
        "progress.md documents Enzyme autodiff pattern for our use case",
        "progress.md documents Optimisers.jl setup and update pattern"
      ],
      "files": []
    },
    {
      "id": "SETUP-001",
      "type": "SETUP",
      "title": "Set up test harness with PythonCall.jl",
      "status": "done",
      "priority": 2,
      "blockedBy": ["RESEARCH-002"],
      "description": "Implement test/test_utils.jl with: (1) julia_to_torch function that converts Julia arrays to PyTorch tensors with correct axis permutation, (2) torch_to_julia for the reverse, (3) compare_results helper for tolerance-based comparison, (4) Verify harness works by round-tripping a test array.",
      "acceptanceCriteria": [
        "julia_to_torch correctly permutes (X,Y,Z,C,N) -> (N,C,Z,Y,X)",
        "torch_to_julia correctly permutes (N,C,Z,Y,X) -> (X,Y,Z,C,N)",
        "compare_results handles both 2D and 3D arrays",
        "Round-trip test passes: arr == torch_to_julia(julia_to_torch(arr))"
      ],
      "files": ["test/test_utils.jl"]
    },
    {
      "id": "IMPL-UTILS-001",
      "type": "IMPL",
      "title": "Implement affine_grid function",
      "status": "done",
      "priority": 3,
      "blockedBy": ["SETUP-001"],
      "description": "Implement affine_grid(theta, size) in src/utils.jl that creates a sampling grid for spatial transformations. This is equivalent to F.affine_grid in PyTorch. Should work for both 2D and 3D.",
      "acceptanceCriteria": [
        "affine_grid works for 2D: size=(X, Y, C, N)",
        "affine_grid works for 3D: size=(X, Y, Z, C, N)",
        "Identity affine produces normalized grid from -1 to 1",
        "Function is type-stable"
      ],
      "files": ["src/utils.jl"],
      "torchregRef": "utils.py:create_grid (line 40-41)"
    },
    {
      "id": "IMPL-UTILS-002",
      "type": "IMPL",
      "title": "Implement Gaussian smoothing kernel",
      "status": "done",
      "priority": 3,
      "blockedBy": ["IMPL-UTILS-001"],
      "description": "Implement smooth_kernel(kernel_size, sigma) in src/utils.jl that creates a Gaussian smoothing kernel. Used by SyN for flow regularization.",
      "acceptanceCriteria": [
        "smooth_kernel produces normalized Gaussian kernel",
        "Works for both 2D and 3D kernel sizes",
        "Kernel sums to 1.0"
      ],
      "files": ["src/utils.jl"],
      "torchregRef": "utils.py:smooth_kernel (line 6-12)"
    },
    {
      "id": "IMPL-UTILS-003",
      "type": "IMPL",
      "title": "Implement Jacobian gradient and determinant",
      "status": "done",
      "priority": 3,
      "blockedBy": ["IMPL-UTILS-002"],
      "description": "Implement jacobi_gradient(u, id_grid) and jacobi_determinant(u, id_grid) in src/utils.jl for computing spatial gradients of displacement fields. Used by LinearElasticity regularizer.",
      "acceptanceCriteria": [
        "jacobi_gradient computes spatial derivatives correctly",
        "jacobi_determinant computes 3x3 determinant of Jacobian",
        "Both handle boundary padding appropriately"
      ],
      "files": ["src/utils.jl"],
      "torchregRef": "utils.py:jacobi_gradient (line 25-37), jacobi_determinant (line 15-22)"
    },
    {
      "id": "TEST-UTILS-001",
      "type": "TEST",
      "title": "Parity tests for utility functions",
      "status": "done",
      "priority": 4,
      "blockedBy": ["IMPL-UTILS-003"],
      "description": "Write parity tests comparing Julia utils to torchreg utils. Test affine_grid, smooth_kernel, jacobi_gradient, jacobi_determinant against PyTorch equivalents.",
      "acceptanceCriteria": [
        "affine_grid matches torchreg create_grid within rtol=1e-5",
        "smooth_kernel matches torchreg smooth_kernel within rtol=1e-5",
        "jacobi_gradient matches within rtol=1e-4",
        "All tests pass with both 2D and 3D inputs"
      ],
      "files": ["test/test_utils.jl"]
    },
    {
      "id": "IMPL-METRICS-001",
      "type": "IMPL",
      "title": "Implement Dice loss and score",
      "status": "done",
      "priority": 5,
      "blockedBy": ["TEST-UTILS-001"],
      "description": "Implement dice_score(x1, x2) and dice_loss(x1, x2) in src/metrics.jl. Dice coefficient measures overlap between two binary/soft masks.",
      "acceptanceCriteria": [
        "dice_score returns value in [0, 1]",
        "dice_loss = 1 - dice_score",
        "Works for both 2D and 3D arrays",
        "Handles batch dimension correctly"
      ],
      "files": ["src/metrics.jl"],
      "torchregRef": "metrics.py:dice_loss, dice_score (line 7-15)"
    },
    {
      "id": "IMPL-METRICS-002",
      "type": "IMPL",
      "title": "Implement Normalized Cross-Correlation (NCC) loss",
      "status": "done",
      "priority": 5,
      "blockedBy": ["IMPL-METRICS-001"],
      "description": "Implement NCC loss as a callable struct in src/metrics.jl. Uses local window correlation.",
      "acceptanceCriteria": [
        "NCC struct with kernel_size parameter",
        "Forward pass computes windowed cross-correlation",
        "Returns negative CC (for minimization)",
        "Works for 2D and 3D"
      ],
      "files": ["src/metrics.jl"],
      "torchregRef": "metrics.py:NCC (line 46-64)"
    },
    {
      "id": "IMPL-METRICS-003",
      "type": "IMPL",
      "title": "Implement LinearElasticity regularizer",
      "status": "done",
      "priority": 5,
      "blockedBy": ["IMPL-METRICS-002"],
      "description": "Implement LinearElasticity regularizer in src/metrics.jl. Penalizes non-smooth deformation fields using strain tensor.",
      "acceptanceCriteria": [
        "LinearElasticity struct with mu, lam parameters",
        "Computes strain tensor from Jacobian",
        "Returns regularization penalty",
        "Works for 3D displacement fields"
      ],
      "files": ["src/metrics.jl"],
      "torchregRef": "metrics.py:LinearElasticity (line 18-43)"
    },
    {
      "id": "TEST-METRICS-001",
      "type": "TEST",
      "title": "Parity tests for metrics",
      "status": "done",
      "priority": 6,
      "blockedBy": ["IMPL-METRICS-003"],
      "description": "Write parity tests for all metrics against torchreg. Use random arrays with fixed seeds for reproducibility.",
      "acceptanceCriteria": [
        "dice_loss matches torchreg within rtol=1e-5",
        "NCC loss matches within rtol=1e-4",
        "LinearElasticity matches within rtol=1e-4",
        "Tests cover both 2D and 3D cases"
      ],
      "files": ["test/test_metrics.jl"]
    },
    {
      "id": "RESEARCH-AD-001",
      "type": "RESEARCH",
      "title": "Evaluate Enzyme.jl vs Mooncake.jl for AD",
      "status": "done",
      "priority": 7,
      "blockedBy": ["TEST-METRICS-001"],
      "description": "Research and compare Enzyme.jl and Mooncake.jl to determine which is better suited for this project. Test both with a minimal example that includes: (1) NNlib.grid_sample differentiation, (2) batched matrix operations, (3) nested function calls. Document findings and make a recommendation.",
      "acceptanceCriteria": [
        "progress.md documents Enzyme.jl API and how to compute gradients",
        "progress.md documents Mooncake.jl API and how to compute gradients",
        "Test both with NNlib.grid_sample - does differentiation work?",
        "Test both with compose_affine-like batched operations",
        "Document any limitations or gotchas for each",
        "Make clear recommendation with justification",
        "Include working code snippets for the chosen library"
      ],
      "files": []
    },
    {
      "id": "FIX-AD-001",
      "type": "FIX",
      "title": "Replace Zygote with chosen AD library (Enzyme or Mooncake)",
      "status": "done",
      "priority": 8,
      "blockedBy": ["RESEARCH-AD-001"],
      "description": "Based on RESEARCH-AD-001 findings, replace ALL Zygote usage with the chosen AD library (Enzyme.jl or Mooncake.jl). This affects src/affine.jl and src/syn.jl fit! functions. Update Project.toml dependencies accordingly.",
      "acceptanceCriteria": [
        "No imports of Zygote anywhere in src/",
        "Chosen AD library used for all gradient computations",
        "src/MedicalImageRegistration.jl updated to use correct AD library",
        "Project.toml updated with correct AD dependency (not Zygote)",
        "fit! functions in affine.jl and syn.jl use new AD gradients",
        "Basic registration still converges after AD change",
        "Tests still pass"
      ],
      "files": ["src/MedicalImageRegistration.jl", "src/affine.jl", "src/syn.jl", "Project.toml"]
    },
    {
      "id": "IMPL-AFFINE-001",
      "type": "IMPL",
      "title": "Verify AffineRegistration works with new AD library",
      "status": "done",
      "priority": 9,
      "blockedBy": ["FIX-AD-001"],
      "description": "After fixing AD, verify that AffineRegistration struct works correctly with the new AD library. May need to adjust how parameters are stored/passed for compatibility.",
      "acceptanceCriteria": [
        "AffineRegistration struct works with chosen AD library",
        "Parameters can be differentiated correctly",
        "No runtime errors during gradient computation"
      ],
      "files": ["src/types.jl", "src/affine.jl"]
    },
    {
      "id": "TEST-AFFINE-001",
      "type": "TEST",
      "title": "Parity tests for AffineRegistration with new AD",
      "status": "done",
      "priority": 10,
      "blockedBy": ["IMPL-AFFINE-001"],
      "description": "Verify that AffineRegistration still produces correct results after AD library migration. Test: (1) compose_affine produces same matrix as torchreg, (2) affine_transform produces same output, (3) Full registration on synthetic data converges similarly.",
      "acceptanceCriteria": [
        "compose_affine matches torchreg within rtol=1e-5",
        "affine_transform matches within rtol=1e-4",
        "Registration converges to similar parameters (rtol=1e-2)",
        "Tests cover 2D and 3D, batch_size=1 and 2"
      ],
      "files": ["test/test_affine.jl"]
    },
    {
      "id": "IMPL-SYN-001",
      "type": "IMPL",
      "title": "Verify SyN registration with new AD library",
      "status": "done",
      "priority": 11,
      "blockedBy": ["TEST-AFFINE-001"],
      "description": "After AD migration, verify SyN registration works correctly. The diffeomorphic operations (scaling-and-squaring) must be differentiable through the chosen AD library.",
      "acceptanceCriteria": [
        "SyN fit! function works with new AD gradients",
        "diffeomorphic_transform is differentiable",
        "Registration produces reasonable output (not NaN/Inf)",
        "Basic convergence test passes"
      ],
      "files": ["src/syn.jl"]
    },
    {
      "id": "TEST-SYN-001",
      "type": "TEST",
      "title": "Parity tests for SyNRegistration with new AD",
      "status": "done",
      "priority": 12,
      "blockedBy": ["IMPL-SYN-001"],
      "description": "Verify SyN registration parity after AD migration. Test: diffeomorphic_transform, gauss_smoothing, basic registration convergence.",
      "acceptanceCriteria": [
        "diffeomorphic_transform matches torchreg within rtol=1e-4",
        "gauss_smoothing matches within rtol=1e-5",
        "SyN registration runs without error on 3D data",
        "Output images are visually reasonable (not NaN/Inf)"
      ],
      "files": ["test/test_syn.jl"]
    },
    {
      "id": "IMPL-2D-001",
      "type": "IMPL",
      "title": "Verify 2D support with new AD library",
      "status": "done",
      "priority": 13,
      "blockedBy": ["TEST-SYN-001"],
      "description": "Verify that all 2D functionality works correctly with the new AD library. Both AffineRegistration and (optionally) SyN should work with 2D arrays.",
      "acceptanceCriteria": [
        "AffineRegistration works with 2D arrays (X, Y, C, N)",
        "All metrics work with 2D",
        "2D registration converges correctly",
        "Tests pass for both 2D and 3D"
      ],
      "files": ["src/affine.jl", "src/syn.jl", "test/"]
    },
    {
      "id": "TEST-INTEGRATION-001",
      "type": "TEST",
      "title": "End-to-end integration tests",
      "status": "done",
      "priority": 14,
      "blockedBy": ["IMPL-2D-001"],
      "description": "Write integration tests that exercise the full registration pipeline: load images, register, verify output quality. Include synthetic test cases with known ground truth.",
      "acceptanceCriteria": [
        "Synthetic translation test: registration recovers translation",
        "Synthetic rotation test: registration recovers rotation",
        "Affine + SyN pipeline works in sequence",
        "No memory leaks or type instabilities"
      ],
      "files": ["test/runtests.jl"]
    },
    {
      "id": "IMPL-GPU-001",
      "type": "IMPL",
      "title": "Integrate AcceleratedKernels.jl for GPU support",
      "status": "open",
      "priority": 15,
      "blockedBy": ["TEST-INTEGRATION-001"],
      "description": "Integrate AcceleratedKernels.jl (AK.jl) for cross-platform GPU acceleration. The package should work transparently on CPU, Metal (Apple Silicon), and CUDA without users having to think about it. Key operations to accelerate: grid sampling, convolutions for smoothing, and any hot loops in the registration.",
      "acceptanceCriteria": [
        "AcceleratedKernels.jl added to Project.toml",
        "GPU-accelerated operations work on CPU (fallback)",
        "GPU-accelerated operations work on Metal (test locally on Mac)",
        "Registration runs significantly faster on GPU vs CPU",
        "Users don't need to explicitly enable GPU - it's automatic",
        "Document which operations benefit from GPU acceleration"
      ],
      "files": ["src/utils.jl", "src/affine.jl", "src/syn.jl", "Project.toml"]
    },
    {
      "id": "SETUP-CI-001",
      "type": "SETUP",
      "title": "Set up GitHub Actions with Mac runner for GPU testing",
      "status": "open",
      "priority": 16,
      "blockedBy": ["IMPL-GPU-001"],
      "description": "Configure GitHub Actions CI to test on both Ubuntu (CPU) and macOS (Metal GPU). The Mac runner will verify that Metal GPU acceleration actually works. Tests should measure and report performance to confirm GPU speedup.",
      "acceptanceCriteria": [
        ".github/workflows/ci.yml updated with macOS job",
        "Ubuntu job runs standard CPU tests",
        "macOS job runs tests with Metal GPU",
        "CI reports pass/fail for both CPU and GPU paths",
        "Performance benchmarks logged (optional but helpful)",
        "Tests catch if GPU acceleration silently falls back to CPU"
      ],
      "files": [".github/workflows/ci.yml"]
    },
    {
      "id": "DEMO-001",
      "type": "IMPL",
      "title": "Create TestImages.jl demo with GIF output",
      "status": "open",
      "priority": 17,
      "blockedBy": ["TEST-INTEGRATION-001"],
      "description": "Create a demo script that uses TestImages.jl to demonstrate registration capabilities. Save a GIF showing before/after registration. Update README with the GIF and demo instructions.",
      "acceptanceCriteria": [
        "Demo script in examples/ directory",
        "Uses TestImages.jl for standard test images",
        "Produces a GIF showing registration animation",
        "README updated to include the demo GIF",
        "Demo works for 2D affine registration"
      ],
      "files": ["examples/demo.jl", "README.md"]
    },
    {
      "id": "DOC-001",
      "type": "RESEARCH",
      "title": "Research and document intensity/HU conservation",
      "status": "open",
      "priority": 18,
      "blockedBy": ["SETUP-CI-001"],
      "description": "Investigate whether spatial transformations preserve intensity values (important for quantitative CT HU analysis). Document which interpolation modes preserve values and which don't. Add 'Intensity Conservation' section to README with practical guidance.",
      "acceptanceCriteria": [
        "Document whether bilinear/trilinear interpolation preserves exact values",
        "Explain trade-offs between nearest-neighbor vs linear interpolation",
        "Document which parts of the pipeline affect intensity values",
        "Add 'Intensity Conservation' section to README",
        "Provide guidance for users who need quantitative analysis"
      ],
      "files": ["README.md"]
    },
    {
      "id": "CLEANUP-001",
      "type": "IMPL",
      "title": "Final cleanup and export verification",
      "status": "done",
      "priority": 19,
      "blockedBy": ["DEMO-001", "DOC-001"],
      "description": "Final pass: verify all exports work, remove any TODO comments, ensure consistent code style, verify package loads cleanly.",
      "acceptanceCriteria": [
        "using MedicalImageRegistration loads without warnings",
        "All exported functions are documented with docstrings",
        "No remaining TODO/FIXME comments",
        "Package precompiles successfully",
        "No Zygote references remain anywhere",
        "AD library choice is baked in - users never see it",
        "GPU acceleration via AK.jl is transparent to users",
        "CI passes on both Ubuntu (CPU) and macOS (Metal GPU)"
      ],
      "files": ["src/MedicalImageRegistration.jl"]
    }
  ],
  "completedStories": []
}

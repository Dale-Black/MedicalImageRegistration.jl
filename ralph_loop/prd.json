{
  "project": "MedicalImageRegistration.jl",
  "description": "Port torchreg to Julia with GPU-first architecture using AK.jl + Mooncake rrule!!",
  "source": "https://github.com/codingfisch/torchreg",
  "philosophy": {
    "gpu_first": "ALL code runs on GPU via AcceleratedKernels.jl. NO CPU fallbacks. NO nested for loops.",
    "ad_strategy": "Use Mooncake.jl with custom rrule!! for GPU-accelerated backward passes",
    "testing": "Test with Metal.jl MtlArrays locally. All tests must pass on GPU.",
    "no_compromises": "If something doesn't work on GPU with AD, fix it properly. No hacks."
  },
  "loopInstructions": {
    "storyTypes": {
      "NUKE": "Delete old broken code and start fresh",
      "RESEARCH": "Study and document approach before implementing",
      "IMPL": "Implement with AK.jl + Mooncake rrule!! from the start",
      "TEST": "Test on Metal GPU with MtlArrays"
    },
    "rules": [
      "EVERY function must work on GPU arrays (MtlArray, CuArray)",
      "EVERY differentiable function needs a Mooncake rrule!!",
      "NO nested for loops - use AK.foreachindex everywhere",
      "NO CPU fallbacks - if it doesn't work on GPU, fix it",
      "Test with MtlArrays locally before marking done"
    ]
  },
  "stories": [
    {
      "id": "NUKE-001",
      "type": "NUKE",
      "title": "Delete all existing src/ code and start fresh",
      "status": "done",
      "priority": 1,
      "blockedBy": [],
      "description": "The current implementation is broken - has CPU fallbacks, nested for loops, and AD hacks. Delete ALL files in src/ except MedicalImageRegistration.jl (keep as empty module). We're starting from scratch with GPU-first architecture.",
      "acceptanceCriteria": [
        "All .jl files in src/ deleted except MedicalImageRegistration.jl",
        "MedicalImageRegistration.jl contains only: module declaration, empty exports",
        "No old broken code remains",
        "Git commit with message: [NUKE-001] Clean slate for GPU-first rewrite"
      ],
      "files": ["src/"]
    },
    {
      "id": "RESEARCH-MOONCAKE-001",
      "type": "RESEARCH",
      "title": "Document Mooncake rrule!! pattern for GPU functions",
      "status": "done",
      "priority": 2,
      "blockedBy": ["NUKE-001"],
      "description": "Before implementing, understand exactly how to write Mooncake rrule!! for GPU-accelerated functions. Document the pattern with a simple example. Test that the pattern works with MtlArrays.",
      "acceptanceCriteria": [
        "progress.md documents Mooncake rrule!! signature",
        "progress.md shows CoDual, NoFData, NoRData usage",
        "progress.md has working example with AK.foreachindex in both forward and backward",
        "Example tested with MtlArrays and gradients verified"
      ],
      "files": []
    },
    {
      "id": "IMPL-GRID-001",
      "type": "IMPL",
      "title": "Implement grid_sample with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 3,
      "blockedBy": ["RESEARCH-MOONCAKE-001"],
      "description": "Implement grid_sample from scratch. Forward pass uses AK.foreachindex. Backward pass uses AK.foreachindex. Both registered with Mooncake rrule!!. Must match PyTorch F.grid_sample output.",
      "acceptanceCriteria": [
        "src/grid_sample.jl with grid_sample function using AK.foreachindex",
        "Mooncake rrule!! defined for grid_sample",
        "Backward pass also uses AK.foreachindex",
        "2D (bilinear) and 3D (trilinear) interpolation",
        "padding_mode :zeros and :border",
        "Matches PyTorch F.grid_sample within rtol=1e-5",
        "Works on MtlArrays - test locally",
        "Gradients verified against finite differences on GPU"
      ],
      "files": ["src/grid_sample.jl", "test/test_grid_sample.jl"]
    },
    {
      "id": "IMPL-AFFINE-GRID-001",
      "type": "IMPL",
      "title": "Implement affine_grid with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 4,
      "blockedBy": ["IMPL-GRID-001"],
      "description": "Implement affine_grid that creates sampling grid from affine matrix. Uses AK.foreachindex. Has Mooncake rrule!! for backward pass.",
      "acceptanceCriteria": [
        "src/affine_grid.jl with affine_grid function using AK.foreachindex",
        "Mooncake rrule!! defined",
        "2D and 3D support",
        "Matches PyTorch F.affine_grid within rtol=1e-5",
        "Works on MtlArrays"
      ],
      "files": ["src/affine_grid.jl"]
    },
    {
      "id": "IMPL-COMPOSE-001",
      "type": "IMPL",
      "title": "Implement compose_affine with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 5,
      "blockedBy": ["IMPL-AFFINE-GRID-001"],
      "description": "Implement compose_affine that builds affine matrix from translation, rotation, zoom, shear. GPU-accelerated with Mooncake rrule!!.",
      "acceptanceCriteria": [
        "src/compose_affine.jl using AK.jl operations",
        "Mooncake rrule!! defined",
        "Matches torchreg compose_affine",
        "Works on MtlArrays"
      ],
      "files": ["src/compose_affine.jl"]
    },
    {
      "id": "IMPL-METRICS-001",
      "type": "IMPL",
      "title": "Implement loss functions with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 6,
      "blockedBy": ["IMPL-COMPOSE-001"],
      "description": "Implement MSE, Dice, NCC losses. All GPU-accelerated with AK.jl. All have Mooncake rrule!!.",
      "acceptanceCriteria": [
        "src/metrics.jl with mse_loss, dice_loss, dice_score, NCC",
        "All use AK.jl for GPU acceleration",
        "All have Mooncake rrule!!",
        "Match torchreg metrics",
        "Work on MtlArrays"
      ],
      "files": ["src/metrics.jl"]
    },
    {
      "id": "IMPL-AFFINE-REG-001",
      "type": "IMPL",
      "title": "Implement AffineRegistration with GPU optimization loop",
      "status": "done",
      "priority": 7,
      "blockedBy": ["IMPL-METRICS-001"],
      "description": "Implement full AffineRegistration. Optimization loop runs entirely on GPU. Uses Mooncake for gradients. Uses Optimisers.jl for updates.",
      "acceptanceCriteria": [
        "src/affine.jl with AffineRegistration struct",
        "fit! function runs entirely on GPU",
        "Mooncake computes gradients through entire forward pass",
        "Multi-resolution pyramid support",
        "register() and transform() API",
        "Converges on test cases with MtlArrays"
      ],
      "files": ["src/affine.jl", "src/types.jl"]
    },
    {
      "id": "IMPL-SYN-001",
      "type": "IMPL",
      "title": "Implement SyN diffeomorphic registration on GPU",
      "status": "done",
      "priority": 8,
      "blockedBy": ["IMPL-AFFINE-REG-001"],
      "description": "Implement SyN registration. Scaling-and-squaring, flow composition, all on GPU with Mooncake AD.",
      "acceptanceCriteria": [
        "src/syn.jl with SyNRegistration struct",
        "diffeomorphic_transform using AK.jl",
        "Mooncake rrule!! for all custom ops",
        "Converges on test cases with MtlArrays"
      ],
      "files": ["src/syn.jl"]
    },
    {
      "id": "TEST-PARITY-001",
      "type": "TEST",
      "title": "Full parity tests against torchreg on GPU",
      "status": "open",
      "priority": 9,
      "blockedBy": ["IMPL-SYN-001"],
      "description": "Comprehensive parity tests comparing Julia GPU implementation against torchreg. All tests run on MtlArrays.",
      "acceptanceCriteria": [
        "grid_sample matches PyTorch within rtol=1e-5",
        "affine_grid matches PyTorch within rtol=1e-5",
        "compose_affine matches torchreg",
        "All metrics match torchreg",
        "AffineRegistration converges similarly to torchreg",
        "All tests use MtlArrays"
      ],
      "files": ["test/"]
    },
    {
      "id": "SETUP-CI-001",
      "type": "IMPL",
      "title": "GitHub Actions CI with Metal GPU testing",
      "status": "open",
      "priority": 10,
      "blockedBy": ["TEST-PARITY-001"],
      "description": "Set up CI that tests on macOS with Metal GPU.",
      "acceptanceCriteria": [
        ".github/workflows/ci.yml with macOS runner",
        "Tests run with Metal.jl",
        "CI passes"
      ],
      "files": [".github/workflows/ci.yml"]
    },
    {
      "id": "DEMO-001",
      "type": "IMPL",
      "title": "Demo with TestImages.jl on GPU",
      "status": "open",
      "priority": 11,
      "blockedBy": ["SETUP-CI-001"],
      "description": "Create demo that runs registration on GPU with TestImages.jl.",
      "acceptanceCriteria": [
        "examples/demo.jl runs on GPU",
        "Produces GIF showing registration",
        "README updated"
      ],
      "files": ["examples/demo.jl", "README.md"]
    },
    {
      "id": "DOC-001",
      "type": "IMPL",
      "title": "Document HU conservation and GPU requirements",
      "status": "open",
      "priority": 12,
      "blockedBy": ["DEMO-001"],
      "description": "Document intensity conservation for CT and GPU requirements.",
      "acceptanceCriteria": [
        "README documents HU conservation implications",
        "README documents GPU requirements (Metal/CUDA)",
        "Clear API documentation"
      ],
      "files": ["README.md"]
    }
  ]
}

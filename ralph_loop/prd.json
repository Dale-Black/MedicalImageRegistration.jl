{
  "project": "MedicalImageRegistration.jl",
  "description": "Port torchreg to Julia with GPU-first architecture using AK.jl + Mooncake rrule!!",
  "source": "https://github.com/codingfisch/torchreg",
  "philosophy": {
    "gpu_first": "ALL code runs on GPU via AcceleratedKernels.jl. NO CPU fallbacks. NO nested for loops.",
    "ad_strategy": "Use Mooncake.jl with custom rrule!! for GPU-accelerated backward passes",
    "testing": "Test with Metal.jl MtlArrays locally. All tests must pass on GPU.",
    "no_compromises": "If something doesn't work on GPU with AD, fix it properly. No hacks."
  },
  "loopInstructions": {
    "storyTypes": {
      "NUKE": "Delete old broken code and start fresh",
      "RESEARCH": "Study and document approach before implementing",
      "IMPL": "Implement with AK.jl + Mooncake rrule!! from the start",
      "TEST": "Test on Metal GPU with MtlArrays"
    },
    "rules": [
      "EVERY function must work on GPU arrays (MtlArray, CuArray)",
      "EVERY differentiable function needs a Mooncake rrule!!",
      "NO nested for loops - use AK.foreachindex everywhere",
      "NO CPU fallbacks - if it doesn't work on GPU, fix it",
      "Test with MtlArrays locally before marking done"
    ]
  },
  "stories": [
    {
      "id": "NUKE-001",
      "type": "NUKE",
      "title": "Delete all existing src/ code and start fresh",
      "status": "done",
      "priority": 1,
      "blockedBy": [],
      "description": "The current implementation is broken - has CPU fallbacks, nested for loops, and AD hacks. Delete ALL files in src/ except MedicalImageRegistration.jl (keep as empty module). We're starting from scratch with GPU-first architecture.",
      "acceptanceCriteria": [
        "All .jl files in src/ deleted except MedicalImageRegistration.jl",
        "MedicalImageRegistration.jl contains only: module declaration, empty exports",
        "No old broken code remains",
        "Git commit with message: [NUKE-001] Clean slate for GPU-first rewrite"
      ],
      "files": ["src/"]
    },
    {
      "id": "RESEARCH-MOONCAKE-001",
      "type": "RESEARCH",
      "title": "Document Mooncake rrule!! pattern for GPU functions",
      "status": "done",
      "priority": 2,
      "blockedBy": ["NUKE-001"],
      "description": "Before implementing, understand exactly how to write Mooncake rrule!! for GPU-accelerated functions. Document the pattern with a simple example. Test that the pattern works with MtlArrays.",
      "acceptanceCriteria": [
        "progress.md documents Mooncake rrule!! signature",
        "progress.md shows CoDual, NoFData, NoRData usage",
        "progress.md has working example with AK.foreachindex in both forward and backward",
        "Example tested with MtlArrays and gradients verified"
      ],
      "files": []
    },
    {
      "id": "IMPL-GRID-001",
      "type": "IMPL",
      "title": "Implement grid_sample with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 3,
      "blockedBy": ["RESEARCH-MOONCAKE-001"],
      "description": "Implement grid_sample from scratch. Forward pass uses AK.foreachindex. Backward pass uses AK.foreachindex. Both registered with Mooncake rrule!!. Must match PyTorch F.grid_sample output.",
      "acceptanceCriteria": [
        "src/grid_sample.jl with grid_sample function using AK.foreachindex",
        "Mooncake rrule!! defined for grid_sample",
        "Backward pass also uses AK.foreachindex",
        "2D (bilinear) and 3D (trilinear) interpolation",
        "padding_mode :zeros and :border",
        "Matches PyTorch F.grid_sample within rtol=1e-5",
        "Works on MtlArrays - test locally",
        "Gradients verified against finite differences on GPU"
      ],
      "files": ["src/grid_sample.jl", "test/test_grid_sample.jl"]
    },
    {
      "id": "IMPL-AFFINE-GRID-001",
      "type": "IMPL",
      "title": "Implement affine_grid with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 4,
      "blockedBy": ["IMPL-GRID-001"],
      "description": "Implement affine_grid that creates sampling grid from affine matrix. Uses AK.foreachindex. Has Mooncake rrule!! for backward pass.",
      "acceptanceCriteria": [
        "src/affine_grid.jl with affine_grid function using AK.foreachindex",
        "Mooncake rrule!! defined",
        "2D and 3D support",
        "Matches PyTorch F.affine_grid within rtol=1e-5",
        "Works on MtlArrays"
      ],
      "files": ["src/affine_grid.jl"]
    },
    {
      "id": "IMPL-COMPOSE-001",
      "type": "IMPL",
      "title": "Implement compose_affine with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 5,
      "blockedBy": ["IMPL-AFFINE-GRID-001"],
      "description": "Implement compose_affine that builds affine matrix from translation, rotation, zoom, shear. GPU-accelerated with Mooncake rrule!!.",
      "acceptanceCriteria": [
        "src/compose_affine.jl using AK.jl operations",
        "Mooncake rrule!! defined",
        "Matches torchreg compose_affine",
        "Works on MtlArrays"
      ],
      "files": ["src/compose_affine.jl"]
    },
    {
      "id": "IMPL-METRICS-001",
      "type": "IMPL",
      "title": "Implement loss functions with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 6,
      "blockedBy": ["IMPL-COMPOSE-001"],
      "description": "Implement MSE, Dice, NCC losses. All GPU-accelerated with AK.jl. All have Mooncake rrule!!.",
      "acceptanceCriteria": [
        "src/metrics.jl with mse_loss, dice_loss, dice_score, NCC",
        "All use AK.jl for GPU acceleration",
        "All have Mooncake rrule!!",
        "Match torchreg metrics",
        "Work on MtlArrays"
      ],
      "files": ["src/metrics.jl"]
    },
    {
      "id": "IMPL-AFFINE-REG-001",
      "type": "IMPL",
      "title": "Implement AffineRegistration with GPU optimization loop",
      "status": "done",
      "priority": 7,
      "blockedBy": ["IMPL-METRICS-001"],
      "description": "Implement full AffineRegistration. Optimization loop runs entirely on GPU. Uses Mooncake for gradients. Uses Optimisers.jl for updates.",
      "acceptanceCriteria": [
        "src/affine.jl with AffineRegistration struct",
        "fit! function runs entirely on GPU",
        "Mooncake computes gradients through entire forward pass",
        "Multi-resolution pyramid support",
        "register() and transform() API",
        "Converges on test cases with MtlArrays"
      ],
      "files": ["src/affine.jl", "src/types.jl"]
    },
    {
      "id": "IMPL-SYN-001",
      "type": "IMPL",
      "title": "Implement SyN diffeomorphic registration on GPU",
      "status": "done",
      "priority": 8,
      "blockedBy": ["IMPL-AFFINE-REG-001"],
      "description": "Implement SyN registration. Scaling-and-squaring, flow composition, all on GPU with Mooncake AD.",
      "acceptanceCriteria": [
        "src/syn.jl with SyNRegistration struct",
        "diffeomorphic_transform using AK.jl",
        "Mooncake rrule!! for all custom ops",
        "Converges on test cases with MtlArrays"
      ],
      "files": ["src/syn.jl"]
    },
    {
      "id": "TEST-PARITY-001",
      "type": "TEST",
      "title": "Full parity tests against torchreg on GPU",
      "status": "done",
      "priority": 9,
      "blockedBy": ["IMPL-SYN-001"],
      "description": "Comprehensive parity tests comparing Julia GPU implementation against torchreg. All tests run on MtlArrays.",
      "acceptanceCriteria": [
        "grid_sample matches PyTorch within rtol=1e-5",
        "affine_grid matches PyTorch within rtol=1e-5",
        "compose_affine matches torchreg",
        "All metrics match torchreg",
        "AffineRegistration converges similarly to torchreg",
        "All tests use MtlArrays"
      ],
      "files": ["test/"]
    },
    {
      "id": "SETUP-CI-001",
      "type": "IMPL",
      "title": "GitHub Actions CI with Metal GPU testing",
      "status": "done",
      "priority": 10,
      "blockedBy": ["TEST-PARITY-001"],
      "description": "Set up CI that tests on macOS with Metal GPU.",
      "acceptanceCriteria": [
        ".github/workflows/ci.yml with macOS runner",
        "Tests run with Metal.jl",
        "CI passes"
      ],
      "files": [".github/workflows/ci.yml"]
    },
    {
      "id": "DEMO-001",
      "type": "IMPL",
      "title": "Demo with TestImages.jl on GPU",
      "status": "done",
      "priority": 11,
      "blockedBy": ["SETUP-CI-001"],
      "description": "Create demo that runs registration on GPU with TestImages.jl.",
      "acceptanceCriteria": [
        "examples/demo.jl runs on GPU",
        "Produces GIF showing registration",
        "README updated"
      ],
      "files": ["examples/demo.jl", "README.md"]
    },
    {
      "id": "DOC-001",
      "type": "IMPL",
      "title": "Document HU conservation and GPU requirements",
      "status": "done",
      "priority": 12,
      "blockedBy": ["DEMO-001"],
      "description": "Document intensity conservation for CT and GPU requirements.",
      "acceptanceCriteria": [
        "README documents HU conservation implications",
        "README documents GPU requirements (Metal/CUDA)",
        "Clear API documentation"
      ],
      "files": ["README.md"]
    },
    {
      "id": "IMPL-NEAREST-001",
      "type": "IMPL",
      "title": "Add nearest-neighbor interpolation to grid_sample",
      "status": "done",
      "priority": 13,
      "blockedBy": ["DOC-001"],
      "description": "Add interpolation_mode kwarg to grid_sample supporting :bilinear/:trilinear (default) and :nearest. Nearest-neighbor preserves original intensity values (critical for HU conservation in CT). Forward pass rounds coordinates to nearest integer instead of bilinear weighting. Backward pass for :nearest returns zero gradients (not differentiable, but that's fine for final output). Must work on GPU with AK.foreachindex.",
      "acceptanceCriteria": [
        "grid_sample accepts interpolation kwarg (:bilinear/:trilinear default, :nearest option)",
        "2D nearest-neighbor: rounds to nearest pixel, returns exact input value",
        "3D nearest-neighbor: rounds to nearest voxel, returns exact input value",
        "Backward pass for :nearest returns zero gradients (non-differentiable)",
        "All padding_mode options work with :nearest",
        "Works on MtlArrays",
        "Matches PyTorch F.grid_sample mode='nearest' within exact equality",
        "Test verifies output values are subset of input values (HU preservation)"
      ],
      "files": ["src/grid_sample.jl", "test/test_grid_sample.jl"]
    },
    {
      "id": "IMPL-HYBRID-001",
      "type": "IMPL",
      "title": "Add hybrid interpolation mode to registration",
      "status": "done",
      "priority": 14,
      "blockedBy": ["IMPL-NEAREST-001"],
      "description": "Add final_interpolation kwarg to register(), transform(), and affine_transform() functions. During optimization, always use bilinear/trilinear for smooth gradients. For final output (and transform() calls), use the specified interpolation mode. Default is :bilinear/:trilinear (unchanged behavior). When final_interpolation=:nearest, the returned image preserves exact input intensity values. Also add to SyN: spatial_transform, apply_flows, etc.",
      "acceptanceCriteria": [
        "register() accepts final_interpolation kwarg (:bilinear default, :nearest option)",
        "transform() accepts interpolation kwarg",
        "affine_transform() accepts interpolation kwarg",
        "AffineRegistration: optimization uses bilinear, final output uses final_interpolation",
        "SyNRegistration: optimization uses trilinear, final output uses final_interpolation",
        "spatial_transform() accepts interpolation kwarg",
        "Default behavior unchanged (bilinear/trilinear throughout)",
        "Works on MtlArrays for both modes",
        "Documentation updated with HU preservation workflow"
      ],
      "files": ["src/affine.jl", "src/syn.jl", "src/types.jl"]
    },
    {
      "id": "TEST-HU-001",
      "type": "TEST",
      "title": "Test HU preservation with hybrid interpolation",
      "status": "done",
      "priority": 15,
      "blockedBy": ["IMPL-HYBRID-001"],
      "description": "Comprehensive tests verifying that final_interpolation=:nearest preserves exact intensity values. Test with synthetic CT-like data with known HU values. Verify that output image values are always a subset of input image values. Test both AffineRegistration and SyNRegistration.",
      "acceptanceCriteria": [
        "Test: grid_sample :nearest output values ⊆ input values",
        "Test: AffineRegistration with final_interpolation=:nearest preserves HU",
        "Test: SyNRegistration with final_interpolation=:nearest preserves HU",
        "Test: transform() with interpolation=:nearest preserves HU",
        "Test: synthetic CT with HU=-1000 (air), 0 (water), 1000 (bone) - values unchanged",
        "Test: registration still converges with hybrid mode (bilinear optimize, nearest output)",
        "All tests on MtlArrays",
        "Document example workflow in test comments"
      ],
      "files": ["test/test_hu_preservation.jl"]
    },
    {
      "id": "DEMO-HU-001",
      "type": "IMPL",
      "title": "Shepp-Logan phantom demo comparing standard vs HU-preserving registration",
      "status": "done",
      "priority": 16,
      "blockedBy": ["TEST-HU-001"],
      "description": "Create a comprehensive demo using the Shepp-Logan phantom (3D via TestImages.shepp_logan(128) if available, otherwise 2D with TestImages.shepp_logan(256)) that visually demonstrates the difference between standard bilinear interpolation and HU-preserving nearest-neighbor hybrid mode. Generate side-by-side GIFs and quantitative analysis showing intensity value preservation.",
      "acceptanceCriteria": [
        "examples/demo_hu_preservation.jl created",
        "Uses TestImages.shepp_logan() - prefer 3D shepp_logan(128) if available, fallback to 2D shepp_logan(256)",
        "Creates synthetic misalignment (rotation + translation)",
        "Runs registration with BOTH modes: standard (bilinear) and hybrid (final_interpolation=:nearest)",
        "Generates GIF: registration_standard.gif showing bilinear interpolation result",
        "Generates GIF: registration_hu_preserving.gif showing nearest-neighbor result",
        "Generates comparison image showing intensity histogram before/after for both modes",
        "Prints quantitative analysis: unique values before vs after, min/max values, value drift statistics",
        "Demo shows that hybrid mode output values are EXACT subset of input values",
        "Demo shows standard mode creates NEW interpolated values not in original",
        "README.md updated with Shepp-Logan demo section and output images",
        "README shows side-by-side comparison of the two approaches",
        "Clear explanation of when to use each mode (visual alignment vs quantitative analysis)",
        "Works on GPU (MtlArray) with CPU fallback"
      ],
      "files": ["examples/demo_hu_preservation.jl", "README.md", "examples/output/"]
    },
    {
      "id": "RESEARCH-CLINICAL-001",
      "type": "RESEARCH",
      "title": "Research clinical CT registration challenges and solutions",
      "status": "done",
      "priority": 17,
      "blockedBy": ["DEMO-HU-001"],
      "description": "Research the challenges of registering real clinical CT scans with mismatched parameters. USE THIS CONCRETE SCENARIO THROUGHOUT: Scan 1 (static): 3mm slice thickness, large FOV (more lung visible), NON-CONTRAST cardiac CT. Scan 2 (moving): 0.5mm slice thickness, tight FOV (less lung), WITH CONTRAST cardiac CT. GOAL: Register these for QUANTITATIVE ANALYSIS where HU accuracy matters (e.g., calcium scoring, tissue density measurement, dose calculation). Document gaps and propose solutions. RESEARCH ONLY - no implementation.",
      "acceptanceCriteria": [
        "Document the CONCRETE USE CASE at the top: cardiac CT, 3mm non-contrast vs 0.5mm contrast, quantitative HU accuracy required",
        "Document in progress.md: DICOM coordinate system (ImagePositionPatient, PixelSpacing, SliceThickness, ImageOrientationPatient)",
        "Document: How to convert between voxel coordinates and physical (mm) coordinates",
        "Document: The problem with contrast vs non-contrast registration - WHY does blood go from 40 HU to 300+ HU?",
        "Document: Specific cardiac structures affected by contrast (chambers, coronary arteries, aorta)",
        "Document: Mutual Information loss - what it is, why it handles multi-modal registration",
        "Document: Anisotropic voxel handling (3mm z vs 0.5mm z) - 6x resolution difference!",
        "Document: The inverse-resampling workflow for true HU preservation",
        "Document: Mask-weighted registration for handling FOV mismatch (tight FOV misses lung)",
        "Document: Quantitative accuracy requirements - what tolerance is acceptable for calcium scoring?",
        "Create a gap analysis table: what current library has vs what's needed FOR THIS USE CASE",
        "Propose implementation order for new features",
        "Research existing Julia packages: DICOM.jl, NIfTI.jl for coordinate handling",
        "NO CODE IMPLEMENTATION - research and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "RESEARCH-MI-001",
      "type": "RESEARCH",
      "title": "Research Mutual Information loss for multi-modal registration",
      "status": "done",
      "priority": 18,
      "blockedBy": ["RESEARCH-CLINICAL-001"],
      "description": "Deep dive into Mutual Information (MI) as a registration loss function. CONTEXT: For our cardiac CT use case (3mm non-contrast vs 0.5mm contrast), MSE/NCC fail because contrast agent changes intensities dramatically. MI measures statistical dependence - if heart blood is always 40 HU in non-contrast and 300 HU in contrast, MI learns this mapping. Research math, GPU challenges, and Mooncake integration.",
      "acceptanceCriteria": [
        "Reference the cardiac CT use case: why MSE fails when blood is 40 HU vs 300 HU",
        "Document MI formula: MI(X,Y) = H(X) + H(Y) - H(X,Y) where H is entropy",
        "Document: Why MI works for contrast/non-contrast (joint histogram learns intensity mapping)",
        "Document: Example joint histogram for cardiac CT - what would it look like?",
        "Document: Parzen window / kernel density estimation for differentiable MI",
        "Document: GPU implementation challenges (histogram binning on GPU with AK.jl)",
        "Document: How torchreg or other libraries implement MI (check ANTs, SimpleITK, etc.)",
        "Document: Normalized Mutual Information (NMI) variant - why it might be better",
        "Document: How to make MI differentiable for gradient-based optimization",
        "Document: Mooncake rrule!! considerations for MI loss - can we autodiff through histograms?",
        "Document: Expected computational cost vs MSE/NCC",
        "Propose implementation approach with AK.jl",
        "NO CODE IMPLEMENTATION - research and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "RESEARCH-PHYSICAL-001",
      "type": "RESEARCH",
      "title": "Research physical coordinate system and anisotropic voxels",
      "status": "done",
      "priority": 19,
      "blockedBy": ["RESEARCH-MI-001"],
      "description": "Research how to properly handle physical coordinates and anisotropic voxels. CONTEXT: Our cardiac CT case has 3mm z-spacing (static) vs 0.5mm z-spacing (moving) - that's 6x difference! Current library uses normalized [-1,1] and treats all voxels as isotropic. A 10-voxel displacement means very different things in physical space. Need to understand coordinate handling for accurate registration.",
      "acceptanceCriteria": [
        "Reference cardiac CT case: 3mm vs 0.5mm z-spacing, what happens if we ignore this?",
        "Document: DICOM coordinate system in detail (LPS vs RAS)",
        "Document: Key DICOM tags for our use case (SliceThickness vs SpacingBetweenSlices)",
        "Document: NIfTI affine matrix and sform/qform",
        "Document: How to compute physical position (mm) of any voxel",
        "Document: The problem - current affine_grid assumes isotropic voxels",
        "Document: Anisotropic grid generation (spacing-aware affine_grid)",
        "Document: How PyTorch/torchreg handles this (or doesn't)",
        "Document: Resampling strategies - should we resample 3mm to 0.5mm or vice versa?",
        "Document: The 'register at low res, apply at high res' workflow in detail",
        "Document: Transform interpolation - upsampling displacement field from 2mm to 0.5mm",
        "Document: What resolution to register at? Trade-offs of 1mm vs 2mm vs 3mm",
        "Propose API changes to support physical coordinates (PhysicalImage type?)",
        "Example: Our two cardiac CTs - step by step what should happen?",
        "NO CODE IMPLEMENTATION - research and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "RESEARCH-WORKFLOW-001",
      "type": "RESEARCH",
      "title": "Design end-to-end clinical CT registration workflow",
      "status": "done",
      "priority": 20,
      "blockedBy": ["RESEARCH-PHYSICAL-001"],
      "description": "Based on previous research, design the COMPLETE workflow for our specific use case: Patient has cardiac CT #1 (3mm, large FOV, non-contrast) and cardiac CT #2 (0.5mm, tight FOV, contrast). Goal: Register them so we can do quantitative analysis (calcium scoring, tissue density) on the registered result with EXACT HU preservation. Design concrete API and implementation plan.",
      "acceptanceCriteria": [
        "Write out the EXACT clinical scenario at the top with specific numbers",
        "Document: Why this matters - calcium scoring requires accurate HU (130 HU threshold)",
        "Document: Complete workflow from two DICOM folders to quantitatively accurate registered output",
        "Document: Step 1 - Load both DICOM series, extract metadata",
        "Document: Step 2 - Compute initial alignment from DICOM headers (are they already in same physical space?)",
        "Document: Step 3 - Determine overlapping FOV (tight FOV is subset of large FOV)",
        "Document: Step 4 - Create common reference grid at registration resolution (e.g., 2mm isotropic)",
        "Document: Step 5 - Downsample BOTH to registration grid (bilinear ok, just for optimization)",
        "Document: Step 6 - Register with MI loss + SyN diffeomorphic (handles local deformation)",
        "Document: Step 7 - Upsample displacement field to 0.5mm resolution",
        "Document: Step 8 - Apply transform to ORIGINAL 0.5mm image with nearest-neighbor",
        "Document: Step 9 - Validation - check that output HU values are exact subset of input",
        "Document: What if user wants to go the other direction (register static to moving)?",
        "Propose: New structs/types (PhysicalImage, DICOMSeries, RegistrationWorkspace)",
        "Propose: New functions (load_dicom_series, compute_overlap_region, resample_transform)",
        "Propose: Changes to existing register() - add physical_coords=true option?",
        "Propose: High-level API - register_clinical(dicom_folder1, dicom_folder2; preserve_hu=true)",
        "Create implementation roadmap with story IDs and dependencies",
        "Estimate complexity (S/M/L) and priority for each new feature",
        "Identify which features are MUST-HAVE vs NICE-TO-HAVE for the cardiac CT use case",
        "NO CODE IMPLEMENTATION - design and documentation only"
      ],
      "files": ["ralph_loop/progress.md"]
    },
    {
      "id": "IMPL-MI-001",
      "type": "IMPL",
      "title": "Implement Mutual Information loss with AK.jl + Mooncake rrule!!",
      "status": "done",
      "priority": 21,
      "blockedBy": ["RESEARCH-WORKFLOW-001"],
      "description": "Implement Mutual Information (MI) loss for multi-modal registration. CONTEXT: For cardiac CT registration (3mm non-contrast vs 0.5mm contrast), MSE fails because contrast changes blood from 40 HU to 300+ HU. MI measures statistical dependence - learns that 40 HU non-contrast = 300 HU contrast. Use differentiable Parzen window estimation. Must work on GPU with AK.jl and have Mooncake rrule!! for backward pass.",
      "acceptanceCriteria": [
        "src/mi_loss.jl with mi_loss function",
        "Differentiable via Parzen window / kernel density estimation",
        "Forward pass: compute joint histogram with AK.foreachindex, then entropy",
        "Backward pass: Mooncake rrule!! using AK.foreachindex",
        "Configurable: number of bins (default 64), kernel sigma",
        "Also implement nmi_loss (Normalized MI) - more robust",
        "Works on MtlArrays - GPU accelerated",
        "Test: mi_loss handles contrast/non-contrast correctly (should decrease as alignment improves)",
        "Test: Gradients verified against finite differences",
        "Test: Matches reference implementation (compare to SimpleITK or ANTs MI if possible)",
        "Document in code: why MI for multi-modal, when to use vs MSE/NCC"
      ],
      "files": ["src/mi_loss.jl", "test/test_mi_loss.jl"]
    },
    {
      "id": "IMPL-PHYSICAL-001",
      "type": "IMPL",
      "title": "Implement physical coordinate handling and spacing-aware grids",
      "status": "done",
      "priority": 22,
      "blockedBy": ["IMPL-MI-001"],
      "description": "Add physical coordinate support for anisotropic voxels. CONTEXT: Cardiac CT case has 3mm z-spacing (static) vs 0.5mm z-spacing (moving) - 6x difference! Current library assumes isotropic normalized [-1,1]. Need spacing-aware grid generation. Add PhysicalImage type that wraps array + spacing + origin. Modify affine_grid and grid_sample to handle physical coordinates.",
      "acceptanceCriteria": [
        "src/physical.jl with PhysicalImage{T,N} struct wrapping (data, spacing, origin)",
        "PhysicalImage stores: data array (X,Y,Z,C,N), spacing tuple (mm), origin tuple (mm)",
        "Constructor: PhysicalImage(data; spacing=(1,1,1), origin=(0,0,0))",
        "affine_grid_physical(theta, image::PhysicalImage) - generates grid in physical coordinates",
        "Grid accounts for anisotropic spacing (a 1mm translation in z = 2 voxels at 0.5mm spacing)",
        "grid_sample works with PhysicalImage, respecting spacing",
        "resample(image::PhysicalImage, target_spacing) - resample to new spacing",
        "resample uses spacing-aware grid internally",
        "Mooncake rrule!! for all new differentiable operations",
        "Works on MtlArrays with AK.foreachindex",
        "Test: Create PhysicalImage with anisotropic spacing, verify grid is correct",
        "Test: Affine transform accounts for spacing difference",
        "Test: Round-trip resample(img, new_spacing) then resample back preserves shape/values"
      ],
      "files": ["src/physical.jl", "test/test_physical.jl"]
    },
    {
      "id": "IMPL-RESAMPLE-001",
      "type": "IMPL",
      "title": "Implement displacement field resampling for multi-resolution workflow",
      "status": "done",
      "priority": 23,
      "blockedBy": ["IMPL-PHYSICAL-001"],
      "description": "Implement functions to upsample/downsample displacement fields. CONTEXT: For cardiac CT workflow, we register at low resolution (2mm isotropic for speed) but need to apply the transform to the high-resolution (0.5mm) original image. Need to upsample the displacement field while maintaining diffeomorphic properties. Also need inverse transform computation for bidirectional registration.",
      "acceptanceCriteria": [
        "src/resample_transform.jl with core functions",
        "resample_displacement(disp_field, target_size) - bilinear/trilinear upsample of displacement field",
        "Displacement values scaled by resolution ratio (2mm->0.5mm means 4x the voxel displacement)",
        "resample_velocity(velocity_field, target_size) - for SyN velocity fields",
        "upsample_affine_transform(theta, old_size, new_size) - adjust affine for resolution change",
        "invert_displacement(disp_field; iterations=10) - iterative inverse (for bidirectional)",
        "All use AK.foreachindex for GPU",
        "All have Mooncake rrule!! (even if gradient is rarely needed)",
        "Works on MtlArrays",
        "Test: Upsample 2x then downsample 2x ≈ identity",
        "Test: Displacement scaling is correct (value * resolution_ratio)",
        "Test: Inverse displacement field inverts original transform (within tolerance)"
      ],
      "files": ["src/resample_transform.jl", "test/test_resample_transform.jl"]
    },
    {
      "id": "IMPL-CLINICAL-001",
      "type": "IMPL",
      "title": "Implement high-level clinical registration API",
      "status": "done",
      "priority": 24,
      "blockedBy": ["IMPL-RESAMPLE-001"],
      "description": "Implement high-level API for clinical CT registration workflow. Combines all previous features into a simple interface. Takes two PhysicalImage arrays, handles resolution mismatch, uses MI loss, applies transform with HU preservation. Should be usable directly from the cardiac_ct.jl notebook.",
      "acceptanceCriteria": [
        "src/clinical.jl with high-level functions",
        "register_clinical(moving::PhysicalImage, static::PhysicalImage; kwargs) - main entry point",
        "Parameters: registration_resolution (default 2mm), loss_fn (default mi_loss), preserve_hu (default true)",
        "Workflow: 1) resample both to registration_resolution, 2) run registration with MI, 3) upsample transform, 4) apply to original with nearest-neighbor",
        "ClinicalRegistrationResult struct with: moved_image, transform, metrics, metadata",
        "transform_clinical(result, image::PhysicalImage) - apply learned transform to another image",
        "Support both AffineRegistration and SyNRegistration via registration_type kwarg",
        "Works entirely on GPU (MtlArrays)",
        "Verbose mode prints: resolution info, registration progress, final metrics",
        "Test: Full workflow with synthetic anisotropic images",
        "Test: Output HU values ⊆ input HU values when preserve_hu=true",
        "Document: Complete example in docstring"
      ],
      "files": ["src/clinical.jl", "test/test_clinical.jl"]
    },
    {
      "id": "TEST-CARDIAC-001",
      "type": "TEST",
      "title": "Test clinical registration on cardiac CT notebook",
      "status": "done",
      "priority": 25,
      "blockedBy": ["IMPL-CLINICAL-001"],
      "description": "Update cardiac_ct.jl notebook to use the new clinical registration API. Test the full pipeline: load DICOMs -> create PhysicalImage -> register with MI loss -> apply transform with HU preservation -> visualize and validate results. This is the ultimate integration test for the cardiac CT use case.",
      "acceptanceCriteria": [
        "examples/cardiac_ct.jl updated with registration cells",
        "Uses load_dicom_volume function already in notebook to get PhysicalImage",
        "Creates PhysicalImage from volume + spacing from DICOM metadata",
        "Calls register_clinical(ccta, non_contrast; preserve_hu=true)",
        "Visualizes: before/after alignment with checkerboard overlay",
        "Visualizes: difference image before/after registration",
        "Validates: Output HU values are exact subset of input (nearest-neighbor working)",
        "Validates: MI loss decreased (alignment improved)",
        "Reports: Registration metrics (MI before/after, NCC before/after)",
        "Reports: Physical metadata (spacing, size, FOV)",
        "Handles the 3mm vs 0.5mm resolution difference correctly",
        "Works on Metal GPU",
        "Add markdown cells explaining each step of the workflow",
        "Notebook can be run end-to-end without errors"
      ],
      "files": ["examples/cardiac_ct.jl"]
    },
    {
      "id": "DOC-CLINICAL-001",
      "type": "IMPL",
      "title": "Document clinical registration workflow in README",
      "status": "pending",
      "priority": 26,
      "blockedBy": ["TEST-CARDIAC-001"],
      "description": "Update README with clinical registration documentation. Add new section explaining the multi-modal registration workflow with concrete cardiac CT example. Document when to use MI vs MSE/NCC. Document physical coordinate handling and HU preservation.",
      "acceptanceCriteria": [
        "README.md has new 'Clinical CT Registration' section",
        "Documents the cardiac CT scenario: non-contrast 3mm vs contrast 0.5mm",
        "Shows complete code example using register_clinical()",
        "Explains MI loss and when to use it (contrast mismatch)",
        "Explains physical coordinates and why they matter (anisotropic voxels)",
        "Explains HU preservation workflow (preserve_hu=true)",
        "Documents PhysicalImage type and how to create one",
        "Documents ClinicalRegistrationResult and what it contains",
        "Table: Which loss to use (MSE for same-modality, MI for different-modality)",
        "Table: Interpolation mode selection (bilinear for visual, nearest for quantitative)",
        "Link to cardiac_ct.jl notebook as example",
        "Clear API reference for new functions"
      ],
      "files": ["README.md"]
    }
  ]
}
